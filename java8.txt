java8 lambda表达式
1.构成：【λ表达式有三部分组成：参数列表，箭头（->），以及一个表达式或语句块】
()->{System.out.println("test");}  //没有入参没有出参

(int x,int y)->x+y;  //隐式返回
(int x,int y)->return x+y;
(x,y)->x+y


类的修饰符public default
对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。
因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。可以满足所有的情况了。
如果类使用了private修饰符，说明是个内部类。内部类的上一级是外部类，那么对应的有四种访问控制修饰符：本类(private)，同包(default)，
父子类(protected)，任何位置(public)。当一个内部类使用了private修饰后，只能在该类的外部类内部使用。




java8 新特性之函数式接口@FunctionalInterface ( Java8提倡函数式变成，因而新增了一个函数式接口，为了更好支持lambda表达式)
java8新增java.util.function包含很多函数式接口类
//我们常用的一些接口Callable、Runnable、Comparator等在JDK8中都添加了@FunctionalInterface注解。
1、该注解只能标记在"有且仅有一个抽象方法"的接口上。(接口有且只能有个一个抽象方法，只有方法定义，没有方法体)

1.1函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。

2、JDK8接口中的静态方法和默认方法(public static 或 public default 修饰的方法)，都不算是抽象方法。

3、接口默认继承java.lang.Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法 (Object.toString() object.equals等）

4、该注解不是必须的，如果一个接口符合"函数式接口"定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。
如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错。

5.函数式接口实例的创建有三种方式：1、lambda表达式；2、方法引用；3、构造方法引用。






java8新特性之接口default默认方法（简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个 default 关键字即可实现默认方法。）
Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态（static）方法
默认方法可以被继承

一个类实现了多个接口，且这些接口有相同的默认方法 
1.创建自己的默认方法，来覆盖重写接口的默认方法
2.可以使用 super 来调用指定接口的默认方法 Vehicle.super.print();


java 向上转型或者向下转型

<? super T> 表示下界通配符 它表示T以及T的超类，类型最高可到Object ，最低是T
<? extends T> 表示上界通配符 它表示T以及T的子类， 类型最高是T

==================================================

java中的容器List和Map及Set都有重写toString()方法，所以对于其中存放了8类基本类型都可以
可以使用System.out.println(list)或System.out.println(map)输出

=========================================================================================================================
Math.random()是java内置产生随机数的函数，Math.random()能够产生[0,1)的浮点数，当我们要产生特定范围的数时，可以采用如下办法：
1.Math.random()*（最大数-最小数+1）+最小数
Math.random()*（a）产生[0-a)的随机数
 如要产生[5-15]的随机数：
int a =(int)(Math.random()*(15-5+1)+5)