securecrt ftp文件方式：
ALT+P
rz 打出上传文件
命令"sz 文件名",即可利用Zmodem将文件下载到本地某目录下

angular8
ctrl+shift+j == F12

---------------------------------------------
int char可相互转化
indexOf(58) 等价 indexOf(':') //58 ascii码值对应“:”
---------------------------------------------


每当 new 一个 Promise 实例的时候，就会 立即执行这个 异步操作中的代码，也就是说，new 的时候，
除了能够得到一个 Promise 实例之外，还会立即调用 我们为 Promise构造函数 传递的那个 function , 执行这个 function 中的 异步操作代码；




securecrt 按下ALT+P就开启新的会话 进行ftp操作。

　　输入：help命令，显示该FTP提供所有的命令

　　pwd:  查询linux主机所在目录（也就是远程主机目录）

　　lpwd: 查询本地目录（一般指windows上传文件的目录：我们可以通过查看"选项"下拉框中的"会话选项",我们知道本地上传目录为：D:/我的文档）

　　ls:   查询连接到当前linux主机所在目录有哪些文件

　　lls:  查询当前本地上传目录有哪些文件

　　lcd:  改变本地上传目录的路径

　　cd:   改变远程上传目录

　　get:  将远程目录中文件下载到本地目录

　　put:  将本地目录中文件上传到远程主机（linux）

　　quit: 断开FTP连接



输出内容至前端页面下载方式：
@RequestMapping(value = "/getPostMan")
public void exportData2PostManJson(HttpServletResponse response){
		JSONObject jsonObject = new JSONObject();
    String uuid = getUUid();
    jsonObject.put("id",uuid);
    jsonObject.put("name","TEST-"+uuid);
    jsonObject.put("description","自动化测试");
    
    response.setHeader("Content-Disposition", "attachment; filename="xx.json");
    Integer contentLength = jsonObject.toJSONString().getBytes().length;
    response.setHeader("content-length", contentLength + "");
    try {
        response.getOutputStream().write(jsonObject.toJSONString().getBytes());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
    

  
springboot中前端ajax传值与后台的接收

第一种方式，不使用任何注解。
前端 
   var data = "username="+vm.username+"&password="+vm.password+"&captcha="+vm.captcha;
            $.ajax({
                type: "POST",
                url: "sys/login",
                data: data,
                dataType: "json",

后台接收
    public R login( String username, String password, String captcha)

 2.使用注解@PathVariable

 前端
     $.get(baseURL + "noticeinfo/info/"+noticeid

后台
    public R info(@PathVariable("noticeid") Integer noticeid) 

  3.使用注解@RequestParam

    前端
     url : baseURL + "noticeinfo/saveimg?noticeid=" + param 

   后台
    public R info(@RequestParam(noticeId) String noticeId)

4. 使用注解@RequestBody

前端
   $.ajax({
                type: "POST",
                url: baseURL + url,
                contentType: "application/json",
                data : JSON.stringify(vm.noticeInfo)

后台 ，有两种方式
   public R update(@RequestBody NoticeInfoEntity noticeInfo) 

   可以直接使用一个map来接收。

   public R update(@RequestBody Map<String, Object> params) 
   

XMLHttpRequest
  try {
                var data = {};
                data['url'] = url;
                data['requestParams'] = text;
                data['response'] = content;
                data['reqTime'] = formatDateToLong(args[0].startedDateTime);
                var xhr = new XMLHttpRequest();
                xhr.withCredentials = true;
                xhr.onerror = function (e) {
                    log("连接异常:", e.stack || e.toString);
                };

                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            log("url:",url,"请求数据成功发送至：" + collectServersIp, xhr.responseText)
                        } else {
                            // 错误处理
                            log("请求数据至收集服务器异常:", xhr.statusText, xhr.responseText);
                        }
                    }
                }

                xhr.open("post", collectServersIp, false);
                xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xhr.send(JSON.stringify(data));
                //log("请求数据推送状态：",xhr.status,"state:",xhr.state);


            } catch (errinfo) {
                log("请求数据发送服务端异常：", errinfo.stack || errinfo.toString());
            }


java程序启动参数-D含义详解
-D<name>=<value>  ：  set a system property  设置系统属性。
java代码中通过System.getProperty("key")获取对应设置的值
Standard System Properties


===================================================================
springboot 使用spring.profiles.active 区分不同环境下配置文件
application.properties文件中增加如下配置
spring.profiles.active=test

则使用test环境，具体resource文件夹下存放文件如下
application.properties
application-test.properties
application-prd.properties

JAVA启动时指定启用配置文件方式：
java -jar app.jar --spring.profiles.active=dev --server.port=8060  //指定端口
=====================================================================

在pom.xml中使用distributionManagement将项目打包上传到nexus私服


1、pom.xml文件添加distributionManagement节点
<!-- 使用分发管理将本项目打成jar包，直接上传到指定服务器 -->
  <distributionManagement>
    <!--正式版本-->
    <repository>
        <!-- nexus服务器中用户名：在settings.xml中<server>的id-->
        <id>yang</id>
        <!-- 这个名称自己定义 -->
        <name>Release repository</name>
        <url>http://192.168.1.105:8081/repository/yang/</url>
    </repository>
    <!--快照
    <snapshotRepository>
        <id>nexus-snapshots</id>
        <name>Snapshots repository</name>
        <url>http://192.168.1.105/repository/yang/</url>
    </snapshotRepository>-->
  </distributionManagement>

< repository >节点下的< id >对应setting.xml文件中的server的id

    <!--maven连接nexus需要验证用户名和密码-->
    <server>
      <id>yang</id>
       <username>admin</username>
       <password>admin123</password>
     </server>

上传正式版本，pom.xml文件version中不能有SNAPSHOT，快照版本才有

  <groupId>com.yang</groupId>
  <artifactId>shade-plugin</artifactId>
  <version>0.0.1</version>
  <!--  <version>0.0.1-SNAPSHOT</version> -->

------------------------------------------------------------------------
内部函数内部使用匿名函数时，this将会指向到全局window对象
var声明的全局变量属于全局对象的属性，即意味着我们可以通过window.变量名的方式访问到。

JS中的this 
https://www.cnblogs.com/echolun/p/11969938.html
https://www.cnblogs.com/echolun/p/11962610.html

1.this的值通常是由当前函数的执行环境所决定；
2.在全局作用域，this指向全局对象 (window对象)；
3.当使用new关键字声明，this指向新建对象；
4.我们可以使用call(), bind(), apply()来设置this；
5.箭头函数不会绑定this，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁

console.dir()查看一个变量、函数、对象内部的属性和值
--------------------------------------------------------------
js中call bind apply
call apply会立即执行，bind会返回一个新方法；
bind、call、apply指明Function函数的this指向（指定的类和Function函数强力的粘贴在一起）

call()和apply()的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用
**call同apply类似，传参时不一样
**bind生成返回新的函数 将

apply：方法能劫持另外一个对象的方法，继承另外一个对象的属性。


function fn(n1,n2){
    return this.name+(n1+n2);
}

var params={
    name:"test by fanghj:"
}

console.log(fn.call(params,11,22));
console.log(fn.apply(params,[10,20]));

console.log(fn.bind(params)(10,20));


bind是返回新的函数，以便稍后调用
它们的第一个参数都是用来更改调用方法中this的指向

bind()方法创建一个新的函数（称为绑定函数）, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。
语法：
fun.bind(thisArg[, arg1[, arg2[, …]]])


1.改变函数运行上下文  
2.改变函数体内部this的指向
3.实现继承 可以让CALL中的对象调用当前对象拥有的function
fn.method.call(b) 即让b拥有fn的method方法并执行如下：
fn.call(x,a,b)   //传参散列化
fn.apply(x,[a,b]) //传参数组
fn.bind(x)(a,b)  //将fn函数bind至对象

var shoppingCart = (function () {
    var _calculatePrice = function () {
        return this.price * this.amount;
    };
    return {
        calculatePrice: _calculatePrice
    }
})();
var goods = {
    name: "hammer",
    price: 199,
    amount: 2
};
shoppingCart.calculatePrice.call(goods);

============================================================
与bind类似的方法还有call和apply，其中的第一个参数都可以理解为  "将自己伪装成参数的成员函数"  其中call和apply 都会立即执行，bind会返回一个新方法。 

如：

function fun(x,y){}

var thisArg = {};

var fun2 = fun.bind(thisArg)

fun2(1,2)

效果等同于

var thisArg = {fun2:function(x,y){}};

thisArg.fun2(1,2);


---------------------------------------------------------


--------------------------------------------------------
js 函数申明的两种方式
1.函数表达式 //不会进行函数提升，需要先申明再调用。使用先于申明会报错
var fn = function(){}  
2.直接申明 //导致函数提升，所有function关键字都会被解释器优先编译，不管是声明在什么位置，都可以调用它，但是它本身不会被执行，定义只是让解释器知道其存在，只有在被调用的时候才会执行
function fn(){
}
第一种方式，函数只能在声明之后调用。因为这种方式声明的函数，是在函数运行的阶段才赋值给变量 f 的；
第二种方式，函数可以在声明函数的作用域内任一地方调用。因为这种方式，是在函数解析阶段赋值给标识符 f .
值得注意的是，当同时使用这两种方式声明同一个函数名，最终执行的是函数表达式声明的函数。


js 反撇号（`）模板字符串加合点位符${} 使用 `${user.name}`


var
1.可以不初始化，值为undefined
2.可以重复声明
3.声明的全局变量为全局对象的属性
4.作用域：函数作用域
5.存在变量提升现象

let 
1.可以不初始化，值为undefined
2.不可重复声明
3.声明的全局变量不是全局对象的属性
3.作用域：块级作用域
4.无变量提升现象

const
1.必须初始化
2.不可重复声明
3.作用域：块级作用域
4.不存在变量提升现象
5.声明的基本数据类型值为常量，之后值不可修改，声明的数组等对象可以进行修改

获取对象属性的方式
1、对象.属性名称  如 obj.age
2、对象[属性名称] 如 obj[age]
3、动态获取属性名称 obj[`${type}`]

优化if-else
1.swith() case方式
2.||或&& 短路求值，三元运算
3.根据类型名放function至map中，调用时通过map.get(type)方式获取执行方法function;
4.根据类型生成object 调用时通过obj[`${type}`]()方式 动态调用执行
具体如下：

let x = x ||"test"  //设置默认值

--------------------------------------------

function del(){
    console.log("del")
}

_Type = new Map();
_Type.set("add",function(){console.log("add")});
_Type.set("del",function(){console.log("del")});
function process(type='del'){
    _Type.get(`${type}`)();
}

process();

---------------------------------------
const rules = {
    "add":function(){
        console.log("add");
    },
    "del":function(){
        console.log("del");
    }
}

let funT = function(x){
    rules[`${x}`]();
}

funT("del");
-------------------------------------------
js 闭包
1. 可以在函数的外部访问到函数内部的局部变量。 
2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。
闭包在JavaScript高级程序设计（第3版）中是这样描述：闭包是指有权访问另一个函数作用域中的变量的函数。
========================================================================================
js中的匿名函数
function fn(){
  console.log('test');
}
去掉普通函数的名字即匿名函数如下
function(){
 console.log('test');
}

匿名函数的执行,外层用()包裹后跟()如下:
(function(){
	console.log('test');
})();

执行需要入参的匿名函数
(function(str){
  console.log('hello'+str);
})('fhj');

备注：
0.(funtion(){})()； 或者(function(){}())立即执行函数；相当于先申明一个函数，声明完后直接调用；
1.由于()优先级高所有声明完函数后立即执行，另外类似的一元操作符!+-可以起到类似的作用如下：!function(){console.log('test')}()
2.通过匿名函数可以实现闭包，执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存，大大降低命名冲突的问题。

JavaScript中的闭包永远都存储在内存中，除非关闭浏览器

JS闭包closure (倒闭，关闭，停业)
1.闭包：A函数嵌套B函数，B函数使用了A函数的内部变量，且A函数返回B函数，这就是闭包(闭包指代的就是内部函数 insider，而非外部函数outer所包含的范围)

2.所谓闭包其实就是一个自带了执行环境（由外层函数提供，即便外层函数销毁依旧可以访问）的特殊函数

3.百度百科：
闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。

JavaScript中的作用域是指变量与函数的作用范围

--------------------------------------------------------------------------------------------------------------------------------------
立即执行函数的作用是：1.创建一个独立的作用域，这个作用域里面的变量，外面访问不到，这样就可以避免变量污染。2.闭包和私有数据
立即执行函数的写法
(function(){}())
!function(){}()
(function(){})()
function 关键字可以进行函数提升，可以任何地方使用，不必先申明再使用；
如果把函数申明用()或+ - !等修饰则变成函数表达式，且后面加()后即可立即执行；

---------------------------------------------------------------------------------------------------------------------------------------------
全站页面置灰方法CSS
html{
filter: grayscale(100);
}
-------------------------------------------------------------
js中this的绑定 https://www.cnblogs.com/echolun/p/11962610.html
1.默认绑定 函数调用无任何调用前缀对象(xx.fun())，在非严格模式下(在严格模式环境中，默认绑定的this指向undefined)，默认绑定this指定全局对象windows
2.隐式绑定 函数调用时前面存在调用它的对象，那么this就会隐式绑定到这个对象上
  如果函数调用前存在多个对象，this指向距离调用自己最近的对象；
  函数作为参数传递或将函数赋值给变量（隐式绑定丢失）实际上都是调用方都改变成被赋值的对象了如下 ：

//函数赋值给变量
var name ="bb";
function fn(){
  let name ="aa";
  console.log(this.name);
}
var fnA = fn; //将fn()赋值给fnA,调用者是fnA,则this为默认绑定指向的为windows 则结果为bb
fnA();
----------------------
// 函数作参数传递
var name = "bb"
var obj={
    name:'objname',
    fun:function(){
    		console.log(this.name);
    }
}

function fnC(params){
	params();
}
fnC(obj.fun); //将obj.fun函数传给funC来执行，执行者为funC,所以结果应当为 bb;


3.显式绑定。通过call apply及bind方法改变this的行为（函数能主动选择自己的上下文）备注：无法改变箭头函数上下文
注意，如果在使用call之类的方法改变this指向时，指向参数提供的是null或者undefined，那么 this 将指向全局对象
fn.call(obj);
fn.apply(obj);
fn.bind(obj)();

fn.call(null);
fn.call(undefined);
fn.apply();

js API内置显式绑定如
var obj={
	name:"test"
}
[1,2,3].forEach(function(){console.log(this.name)},obj);

4.new绑定，this指向new创建的对象
5.this绑定优化级
 显式绑定 > 隐式绑定 > 默认绑定
 new绑定 > 隐式绑定 > 默认绑定
6.箭头函数的this：箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁
  


============================================================
JS作用域链与原型链的区别：
当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象window，如果window都没有这个变量则报错。
当在对象上访问某属性时，首选i会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是null，如果全程都没找到则返一个undefined，而不是报错。
--------------------------------------------
var 与 let区别
1.var属于ES5范畴,let属于ES6
2.var有预处理机制，let没有。（预处理机制也就是常说的声明提前）　
  备注：声明提前：不管变量被声明在函数什么位置，所有变量声明都会被提升至函数顶部（变量声明指 var a; 即声明还未赋值
   即使在函数内部，声明变量时一定要加上var，不要只写 a = 1; 否则变量a会自动升为全局变量
3.作用域的不同，var是全局作用域，let是块级作用域 (let定义的变量只在{}里才能访问到)
　<script>
        if(true) {
            var let = 1;
        }
        console.log(a); //报错
    </script>
------------------------------------------------------------------------
call、apply与bind有什么区别？
1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，
	这也是为什么上方例子中bind后还加了一对括号 ()的原因。
2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。
3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，
	因为apply在执行时还要多一步解析数组。
	
apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.
=========================================================
js 模板
function fn(name){
	return `my name is :${name}`;
}

============================================================
js 原型链
Promise
eval

-----------------------------------------------------
javascript中的this指向问题：https://www.cnblogs.com/isaboy/archive/2015/10/29/javascript_this.html
函数是否是new进行调用 this 指向创建的对象
             是否使用.调用，是的话，指定.前面的对象，否则指向全局window
             
Arrow Function 词法作用域，没有this 所谓的词法作用域就是一个变量的作用在定义的时候就已经被定义好，当在本作用域中找不到变量，就会一直向父作用域中查找，直到找到为止。

JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因
“JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，
构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，
首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，
则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）
创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。
最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，
函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。”

-----------------------------------------------------------------------------------------------
js new 过程 https://www.cnblogs.com/echolun/p/10903290.html
在《JavaScript模式》这本书中，new的过程说的比较直白，当我们new一个构造器，主要有三步：
1 创建一个空对象，将它的引用赋给 this，继承函数的原型。
2 通过 this 将属性和方法添加至这个对象
3 最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象）

-------------------------------------------------------------------------------------------------
JS对象创建方法：
1.直接量创建（推荐方式）
let obj={name:'',age:12};
obj.method=function(){};
obj.name="";

let obj1={
	name:"xxx",
	method:function(){}
}

2.通过构造函数创建对象
let obj = new Object();
obj.name=""
obj.method=function(){}

3.自定义构造函数创建对象 //建议将所有实例都需要用到的属性添加在prototype上，因为这样在每次new时，不用每次新开内存时都创建一次
//第一，加在原型链上，new实例时不需要反复创建属性造成内存浪费，第二，简化构造函数的属性能减轻对不需要这些属性的实例的困扰，这也是原型链继承的好处
var Person = function(){
  // var this = {}; 创建一个空对象，将它的引用赋给this，继承函数的原型 准确来说是// var this = Object.create(Person.prototype);
	this.name = "xx";
	this.sayName=function(){  //new 一次sayName()方法会反复的被添加到this中，且每次sayName()方法都会在内存中新开内存
		console.log(this.name)
	}
	//return this; 这里隐性返回的其实就是上面创建的空对象，这个空对象被赋予了name属性和一个sayName方法
}
Person.prototype.sayname=function(){}  //解决上述内存占用问题，将方法添加至Person原型上

var p = new Person();
p.sayName();

4.利用构造函数模式实现多继承
function Cat () {
  this.legs = 4;
  this.say = function () {
    console.log('喵~')
  }
};
function Bird() {
  this.wings = 2;
  this.fly = true;
}
function CatWings() {
  Cat.apply(this);
  Bird.apply(this);
};
let miao = new CatWings();
console.dir(miao);

--------------------------------------------------
/**
 * 控制重复执行提交
 * @param {*} fn 需要执行方法
 * @param {*} delay 多久内执行有效
 */
function debounce(fn,delay){
    var timeout = null;
    var startDate = new Date();
    return function(){
        var endDate = new Date();
        clearTimeout(timeout);
        if(endDate-startDate>=delay){
           fn();
        }else{
            timeout = setTimeout(function(){
                fn();
            },delay)
        }
        startDate = endDate;

    }
}

var btn = document.getElementById("btn");
btn.addEventListener("click",debounce(function(){
    $.ajax({
        url:"",
        success:function(res){
            console.log(res)
        }
    })
},1000),false);

================================================
JS执行上下文：https://www.cnblogs.com/echolun/p/11438363.html
1.执行上下文有且只有三类，全局执行上下文，函数执行上下文，与eval上下文
1.1全局执行上下文 一般由客户端浏览器创建如 window对象，全局对象window上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，
同时window对象还是var声明的全局变量的载体。我们通过var创建的全局对象，都可以通过window直接访问

1.2 函数执行上下文

在执行上下文的执行阶段，进行变量对象的赋值，函数的引用等


函数形参，是指函数声明时定义在圆括号里的形式参数，不是一个确切值。
函数实参，是指函数调用时提供的实际参数，是一个确切值，arguments指向实参引用，这个没问题。

function fn(){
	console.log(arguments)；
}

---------------------------------
js 编码规范：https://www.cnblogs.com/echolun/p/11408779.html
js 执行上下文：
https://www.cnblogs.com/shaunyang/p/10337099.html
https://www.cnblogs.com/lishuxue/p/6558788.html

执行上下文
1.全局执行上下文（JS代码加载完毕后，进入代码预编译即进入全局环境）
2.函数环境执行上下文（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
3.eval执行上下文（不建议使用，会有安全，性能等问题）

执行上下文重要属性
1.变量对象：存储了在上下文中定义的变量和函数声明
2.作用域链(Scope chain)，和原型链类似，当查找变量时，会先在当前上下文变量对象中查找，如果没有会去父级上下文变量对象中查找，直到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链
3.this

执行栈（调用栈）
具有 LIFO（后进先出）用于存储在代码执行期间创建的所有执行上下文
首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶
栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文

创建过程
创建变量对象（创建arguments对象，检查函数申明，检查变量申明）
创建作用链 将当前作用域添加至作用链顶端
确定this指向 (全局上下文指向window 函数根据情况指向)

1.创建arguments对象，检查当前上下文中的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
2.函数声明。检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。(function声明会比var声明优先级更高一点)。
3.变量声明。检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

变量提升的原因：
在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。
所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。
从创建顺序看，函数提升优先于变量提升。


执行阶段：完成对所有变量的分配，最后执行代码
变量赋值
函数引用
执行其他代码

------------------------------------
理解this的第一步就是要明白：this既不指向函数自身，也不指向函数的词法作用域；

this是在运行时进行绑定的，而不是在编写时绑定，它的上下文取决于函数调用时的各种条件；

this的绑定和函数声明的位置没有任何关系，只取决于函数的调用位置和调用方式；

this绑定规则有4点：按优先级1到4判断

1.由new调用？绑定到新创建的空对象；

2.由call、apply、bind调用？绑定到指定的参数对象；如foo.call(obj)

3.由上下文对象调用？绑定到这个上下文对象；如obj.foo()

4.默认情况下绑定到全局对象，foo()；在严格模式下绑定到undefined；

========================================================
this指向总结：
this是运行时绑定的，全局函数中的this是window（严格模式undefined），而当函数作为某个对象的方法调用时，this就是指的那个对象
1.对象中普通函数中的this指向的是对象，对象函数中嵌套的返回的匿名函数（闭包）指向window，对象函数是箭头函数指向的window
2.对象函数中嵌套返回的箭头函数没有自已的this，其this指向外部函数（外部上下文的this指向）
3.通过new对象或构造函数中，普通函数箭头函数指向对象，对象函数中嵌套的返回的匿名函数（闭包）指向window
4.可以通过apply call bind修改this(箭头函数除外)
5.函数中嵌套返回匿名闭包函数时，可以先将this赋值给一个变量，然后闭包访问这个变量
如：
let obj={
	 name:"objname",
	 get:function(){
	 		var that = this;
	 	  return function(){
	 	  	console.log(that.name)
	 	  }
	 }
}























变量提升是将变量声明提升到它所在作用域的最开始的部分

javascript代码执行过程分两个阶段
1.代码编译阶段 将代码翻译成可执行代码
2.代码执行阶段（由引擎完成）执行上下文会在这个阶段创建，
执行上下文（执行上下文可以理解为当前代码的执行环境，它会形成一个作用域）的创建也分创建阶段 及执行阶段






当调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。
创建阶段：在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。
代码执行：创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。


执行上下文（Execution Context）代码被解析或执行所在环境的抽象概念，（JavaScript中的运行环境）
全局执行上下文（JS代码加载完毕后，进入代码预编译即进入全局环境）
函数环境执行上下文（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
eval执行上下文（不建议使用，会有安全，性能等问题）
当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，
而栈顶就是当前正在执行的上下文。处于栈顶的上下文执行完毕之后，就会自动出栈。

对于每个执行上下文，都有三个重要属性：
1.变量对象(Variable object，VO)，存储了在上下文中定义的变量和函数声明。在全局执行上下文中指window，函数执行上下文中就是活动对象（AO）
2.作用域链(Scope chain)，和原型链类似，当查找变量时，会先在当前上下文变量对象中查找，如果没有会去父级上下文变量对象中查找，直到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链



词法环境，变量环境
变量对象  活动对象


