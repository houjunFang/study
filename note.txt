java 枚举类
java 单例

子类重写父类方法时，方法的访问权限不可小于原访问权限。

----------------------------
java 构造方法总结：
构造方法: 方法名同类型([参数列表]){}
1.方法名与类名相同，方法名前没有返回值类型申明（void 也不可以），方法中不能有return返回一个值；
2.构造方法同普通方法可以重载（但构造方法是不被继承的），以参数的个数，类型，或排列顺序区分；
3.构造函数不能被继承，也不能直接被调用；构造方法可以通过this()调用其他构造函数，通过super()调用父类构造函数，但这两个都方法都必须是调用方法的第一句；
4.创建子类对象时，首先执行父类构造方法，然后再执行子类构造方法；多级继承情况下，从继承最上层开始依次执行各类的构造方法；
如果子类构造方法中没有super语句显示调用父类的构造方法，创建子类对象时会自动调用父类默认的构造方法，若父类没有默认构造方法，则编译出错。
5.每个类中至少有一个构造函数，如果没有系统会创建一个默认的无参构造函数，若已定义构造方法后则不会再自动创建默认的无参构造函数了；
4.构造方法不能由编程人员调用，而要系统调用
5.构造方法不能被static、final、synchronized、abstract和native修饰
6 构造方法被调用的几种方式：当前类的其他构造方法通过this语句调用它；当前类的子类的构造方法通过super语句调用它；在程序中通过new语句调用它。
7构造方法可以处于public、protected、private和默认四种访问级别之一。
 当构造方法为private级别时，意味着只能在当前类访问它，不能被继承，不能被其他程序用new创建实例对象。
 abstract修饰的类，不允许被实例化，这点和private修饰构造方法相同，但abstract修饰的类可以被继承，拥有子类，可以创建子类的实例；
 final类禁止被继承，这点和private修饰构造方法相同，但是final类可以用new创建实例对象。
 
且必须作为构造方法的第一条语句，成员方法中不可调用构造方法。
父类的构造方法不能被子类继承，但是，在子类的构造方法中可以通过super语句调用父类的构造方法。使用super语句应该注意：在子类的构造方法中使用super语句，它必须作为第一条语句。
在创建子类的对象时，java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法，在多级继承的情况下，将从继承树的最上层得父类开始，依次执行各个类的构造方法，这可以保证子类对象从所有直接或间接父类中继承的实例变量都被正确的初始化。
如果子类的构造方法中没有用super语句显示调用父类的构造方法，那么通过这个构造方法创建子类对象时，java虚拟机会自动先调用父类的默认构造方法，而此时若父类没有默认构造方法时，就是编译出错





java 修饰符
访问修饰符
default(friendly) 默认访问模式，默认修饰符（即不加任何访问修饰符），只允许在同一包内访问；使用对象：类，接口，变量，方法
private 私有访问修饰符。被其修饰的内部类，属性，方法只可在本类中访问，其子类不可访问，更不允许跨包访问。使用对象：变量，方法。注意：外部类不可修饰 （访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据）
protected 保护型访问修饰符，被其修饰的内部类，属性，方法仅能被其本身类或其子类访问，即使子类不在同一包中。 使用对象：变量，方法，注意：不能修饰外部内，接口及接口成员方法及成员变量
public 公共访问修饰符，可以被任何对象访问，被其修饰的类，方法，属性不仅可以跨类访问而且允许跨包访问。使用对象：类，接口，变量，方法 （接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public）

非访问修饰符
static
final

访问修饰符的继承
1.父类声明private方法 不能被继承；
2.父类申明public方法，子类方法必须也只能是public；
3.父类声明protected方法，子类方法只能声明为protected或public,不能为private



接口，比抽象类还要抽象的类:

接口中的方法会被隐式的指定为  public abstract （只能是 public abstract，其他修饰符都会报错）。
接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）
java接口里的成员变量只能是public 的，static 的，final的；并且必须赋初值，否则通不过编译。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
注：
接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。
接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字。
接口中的方法都是公有的( public ) ！！！ 不是 default

public: 使接口的实现类可以使用这个常量
static：接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。
            static修饰就表示它属于类的，随的类的加载而存在的，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了。
            如果是非static的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为static。
final：
            接口中不可以定义变量即定义的变量前都要加上final修饰，使之成为常量(没有final修饰的是变量，加上final修饰就会变成常量)。所以接口的属性默认是public static final 常量，且必须赋初值。
            （  final修饰就是保证接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意去修改的话，接口建立这个常量就没有意义了。）
 
接口中方法的修饰符：public abstract（默认不写）
abstract：
接口仅仅描述系统能做什么，但是不指名如何去做，所以接口中的方法都是抽象（abstract）方法。


Xmind
-------------------
股票量化：https://blog.csdn.net/wuu1299/article/details/78965555?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase
https://blog.csdn.net/weixin_44434573/article/details/86491664?utm_medium=distribute.pc_relevant_download.none-task-blog-BlogCommendFromBaidu-6.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-BlogCommendFromBaidu-6.nonecas

https://github.com/daveqin/stock/blob/master/README.md

java 字节码查看IDEA插件工具：jclasslib

ngModel指令需要引入 import {FromsModule} '@angular/froms'
当在表单中使用[(ngModel)]时，必须要定义name属性。

providers - 一个数组，包含组件所依赖的服务所需要的依赖注入提供者，可用于当前Component及其子视图；


securecrt ftp文件方式：
ALT+P
rz 打出上传文件
命令"sz 文件名",即可利用Zmodem将文件下载到本地某目录下

angular8
ctrl+shift+j == F12

---------------------------------------------
int char可相互转化
indexOf(58) 等价 indexOf(':') //58 ascii码值对应“:”
---------------------------------------------


每当 new 一个 Promise 实例的时候，就会 立即执行这个 异步操作中的代码，也就是说，new 的时候，
除了能够得到一个 Promise 实例之外，还会立即调用 我们为 Promise构造函数 传递的那个 function , 执行这个 function 中的 异步操作代码；




securecrt 按下ALT+P就开启新的会话 进行ftp操作。

　　输入：help命令，显示该FTP提供所有的命令

　　pwd:  查询linux主机所在目录（也就是远程主机目录）

　　lpwd: 查询本地目录（一般指windows上传文件的目录：我们可以通过查看"选项"下拉框中的"会话选项",我们知道本地上传目录为：D:/我的文档）

　　ls:   查询连接到当前linux主机所在目录有哪些文件

　　lls:  查询当前本地上传目录有哪些文件

　　lcd:  改变本地上传目录的路径

　　cd:   改变远程上传目录

　　get:  将远程目录中文件下载到本地目录

　　put:  将本地目录中文件上传到远程主机（linux）

　　quit: 断开FTP连接



输出内容至前端页面下载方式：
@RequestMapping(value = "/getPostMan")
public void exportData2PostManJson(HttpServletResponse response){
		JSONObject jsonObject = new JSONObject();
    String uuid = getUUid();
    jsonObject.put("id",uuid);
    jsonObject.put("name","TEST-"+uuid);
    jsonObject.put("description","自动化测试");
    
    response.setHeader("Content-Disposition", "attachment; filename="xx.json");
    Integer contentLength = jsonObject.toJSONString().getBytes().length;
    response.setHeader("content-length", contentLength + "");
    try {
        response.getOutputStream().write(jsonObject.toJSONString().getBytes());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
    

  
springboot中前端ajax传值与后台的接收

第一种方式，不使用任何注解。
前端 
   var data = "username="+vm.username+"&password="+vm.password+"&captcha="+vm.captcha;
            $.ajax({
                type: "POST",
                url: "sys/login",
                data: data,
                dataType: "json",

后台接收
    public R login( String username, String password, String captcha)

 2.使用注解@PathVariable

 前端
     $.get(baseURL + "noticeinfo/info/"+noticeid

后台
    public R info(@PathVariable("noticeid") Integer noticeid) 

  3.使用注解@RequestParam

    前端
     url : baseURL + "noticeinfo/saveimg?noticeid=" + param 

   后台
    public R info(@RequestParam(noticeId) String noticeId)

4. 使用注解@RequestBody

前端
   $.ajax({
                type: "POST",
                url: baseURL + url,
                contentType: "application/json",
                data : JSON.stringify(vm.noticeInfo)

后台 ，有两种方式
   public R update(@RequestBody NoticeInfoEntity noticeInfo) 

   可以直接使用一个map来接收。

   public R update(@RequestBody Map<String, Object> params) 
   

XMLHttpRequest
  try {
                var data = {};
                data['url'] = url;
                data['requestParams'] = text;
                data['response'] = content;
                data['reqTime'] = formatDateToLong(args[0].startedDateTime);
                var xhr = new XMLHttpRequest();
                xhr.withCredentials = true;
                xhr.onerror = function (e) {
                    log("连接异常:", e.stack || e.toString);
                };

                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            log("url:",url,"请求数据成功发送至：" + collectServersIp, xhr.responseText)
                        } else {
                            // 错误处理
                            log("请求数据至收集服务器异常:", xhr.statusText, xhr.responseText);
                        }
                    }
                }

                xhr.open("post", collectServersIp, false);
                xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xhr.send(JSON.stringify(data));
                //log("请求数据推送状态：",xhr.status,"state:",xhr.state);


            } catch (errinfo) {
                log("请求数据发送服务端异常：", errinfo.stack || errinfo.toString());
            }


java程序启动参数-D含义详解
-D<name>=<value>  ：  set a system property  设置系统属性。
java代码中通过System.getProperty("key")获取对应设置的值
Standard System Properties


===================================================================
springboot 使用spring.profiles.active 区分不同环境下配置文件
application.properties文件中增加如下配置
spring.profiles.active=test

则使用test环境，具体resource文件夹下存放文件如下
application.properties
application-test.properties
application-prd.properties
备配置文件格式:application-{profile}.properties 或 application-{profile}.yml


JAVA启动时指定启用配置文件方式：
java -jar app.jar --spring.profiles.active=dev --server.port=8060  //指定端口
=====================================================================

在pom.xml中使用distributionManagement将项目打包上传到nexus私服


1、pom.xml文件添加distributionManagement节点
<!-- 使用分发管理将本项目打成jar包，直接上传到指定服务器 -->
  <distributionManagement>
    <!--正式版本-->
    <repository>
        <!-- nexus服务器中用户名：在settings.xml中<server>的id-->
        <id>yang</id>
        <!-- 这个名称自己定义 -->
        <name>Release repository</name>
        <url>http://192.168.1.105:8081/repository/yang/</url>
    </repository>
    <!--快照
    <snapshotRepository>
        <id>nexus-snapshots</id>
        <name>Snapshots repository</name>
        <url>http://192.168.1.105/repository/yang/</url>
    </snapshotRepository>-->
  </distributionManagement>

< repository >节点下的< id >对应setting.xml文件中的server的id

    <!--maven连接nexus需要验证用户名和密码-->
    <server>
      <id>yang</id>
       <username>admin</username>
       <password>admin123</password>
     </server>

上传正式版本，pom.xml文件version中不能有SNAPSHOT，快照版本才有

  <groupId>com.yang</groupId>
  <artifactId>shade-plugin</artifactId>
  <version>0.0.1</version>
  <!--  <version>0.0.1-SNAPSHOT</version> -->

------------------------------------------------------------------------
内部函数内部使用匿名函数时，this将会指向到全局window对象
var声明的全局变量属于全局对象的属性，即意味着我们可以通过window.变量名的方式访问到。

JS中的this 
https://www.cnblogs.com/echolun/p/11969938.html
https://www.cnblogs.com/echolun/p/11962610.html

1.this的值通常是由当前函数的执行环境所决定；
2.在全局作用域，this指向全局对象 (window对象)；
3.当使用new关键字声明，this指向新建对象；
4.我们可以使用call(), bind(), apply()来设置this；
5.箭头函数不会绑定this，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁

console.dir()查看一个变量、函数、对象内部的属性和值
--------------------------------------------------------------
js中call bind apply
call apply会立即执行，bind会返回一个新方法；
bind、call、apply指明Function函数的this指向（指定的类和Function函数强力的粘贴在一起）

call()和apply()的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用
**call同apply类似，传参时不一样
**bind生成返回新的函数 将

apply：方法能劫持另外一个对象的方法，继承另外一个对象的属性。


function fn(n1,n2){
    return this.name+(n1+n2);
}

var params={
    name:"test by fanghj:"
}

console.log(fn.call(params,11,22));
console.log(fn.apply(params,[10,20]));

console.log(fn.bind(params)(10,20));


bind是返回新的函数，以便稍后调用
它们的第一个参数都是用来更改调用方法中this的指向

bind()方法创建一个新的函数（称为绑定函数）, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。
语法：
fun.bind(thisArg[, arg1[, arg2[, …]]])


1.改变函数运行上下文  
2.改变函数体内部this的指向
3.实现继承 可以让CALL中的对象调用当前对象拥有的function
fn.method.call(b) 即让b拥有fn的method方法并执行如下：
fn.call(x,a,b)   //传参散列化
fn.apply(x,[a,b]) //传参数组
fn.bind(x)(a,b)  //将fn函数bind至对象

var shoppingCart = (function () {
    var _calculatePrice = function () {
        return this.price * this.amount;
    };
    return {
        calculatePrice: _calculatePrice
    }
})();
var goods = {
    name: "hammer",
    price: 199,
    amount: 2
};
shoppingCart.calculatePrice.call(goods);

============================================================
与bind类似的方法还有call和apply，其中的第一个参数都可以理解为  "将自己伪装成参数的成员函数"  其中call和apply 都会立即执行，bind会返回一个新方法。 

如：

function fun(x,y){}

var thisArg = {};

var fun2 = fun.bind(thisArg)

fun2(1,2)

效果等同于

var thisArg = {fun2:function(x,y){}};

thisArg.fun2(1,2);


---------------------------------------------------------


--------------------------------------------------------
js 函数申明的两种方式
1.函数表达式 //不会进行函数提升，需要先申明再调用。使用先于申明会报错
var fn = function(){}  
2.直接申明 //导致函数提升，所有function关键字都会被解释器优先编译，不管是声明在什么位置，都可以调用它，但是它本身不会被执行，定义只是让解释器知道其存在，只有在被调用的时候才会执行
function fn(){
}
第一种方式，函数只能在声明之后调用。因为这种方式声明的函数，是在函数运行的阶段才赋值给变量 f 的；
第二种方式，函数可以在声明函数的作用域内任一地方调用。因为这种方式，是在函数解析阶段赋值给标识符 f .
值得注意的是，当同时使用这两种方式声明同一个函数名，最终执行的是函数表达式声明的函数。


js 反撇号（`）模板字符串加合点位符${} 使用 `${user.name}`


var
1.可以不初始化，值为undefined
2.可以重复声明
3.声明的全局变量为全局对象的属性
4.作用域：函数作用域
5.存在变量提升现象

let 
1.可以不初始化，值为undefined
2.不可重复声明
3.声明的全局变量不是全局对象的属性
3.作用域：块级作用域
4.无变量提升现象

const
1.必须初始化
2.不可重复声明
3.作用域：块级作用域
4.不存在变量提升现象
5.声明的基本数据类型值为常量，之后值不可修改，声明的数组等对象可以进行修改

获取对象属性的方式
1、对象.属性名称  如 obj.age
2、对象[属性名称] 如 obj[age]
3、动态获取属性名称 obj[`${type}`]

优化if-else
1.swith() case方式
2.||或&& 短路求值，三元运算
3.根据类型名放function至map中，调用时通过map.get(type)方式获取执行方法function;
4.根据类型生成object 调用时通过obj[`${type}`]()方式 动态调用执行
具体如下：

let x = x ||"test"  //设置默认值

--------------------------------------------

function del(){
    console.log("del")
}

_Type = new Map();
_Type.set("add",function(){console.log("add")});
_Type.set("del",function(){console.log("del")});
function process(type='del'){
    _Type.get(`${type}`)();
}

process();

---------------------------------------
const rules = {
    "add":function(){
        console.log("add");
    },
    "del":function(){
        console.log("del");
    }
}

let funT = function(x){
    rules[`${x}`]();
}

funT("del");
-------------------------------------------
js 闭包
1. 可以在函数的外部访问到函数内部的局部变量。 
2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。
闭包在JavaScript高级程序设计（第3版）中是这样描述：闭包是指有权访问另一个函数作用域中的变量的函数。
========================================================================================
js中的匿名函数
function fn(){
  console.log('test');
}
去掉普通函数的名字即匿名函数如下
function(){
 console.log('test');
}

匿名函数的执行,外层用()包裹后跟()如下:
(function(){
	console.log('test');
})();

执行需要入参的匿名函数
(function(str){
  console.log('hello'+str);
})('fhj');

备注：
0.(funtion(){})()； 或者(function(){}())立即执行函数；相当于先申明一个函数，声明完后直接调用；
1.由于()优先级高所有声明完函数后立即执行，另外类似的一元操作符!+-可以起到类似的作用如下：!function(){console.log('test')}()
2.通过匿名函数可以实现闭包，执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存，大大降低命名冲突的问题。

JavaScript中的闭包永远都存储在内存中，除非关闭浏览器

JS闭包closure (倒闭，关闭，停业)
1.闭包：A函数嵌套B函数，B函数使用了A函数的内部变量，且A函数返回B函数，这就是闭包(闭包指代的就是内部函数 insider，而非外部函数outer所包含的范围)

2.所谓闭包其实就是一个自带了执行环境（由外层函数提供，即便外层函数销毁依旧可以访问）的特殊函数

3.百度百科：
闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。

JavaScript中的作用域是指变量与函数的作用范围

--------------------------------------------------------------------------------------------------------------------------------------
立即执行函数的作用是：1.创建一个独立的作用域，这个作用域里面的变量，外面访问不到，这样就可以避免变量污染。2.闭包和私有数据
立即执行函数的写法
(function(){}())
!function(){}()
(function(){})()
function 关键字可以进行函数提升，可以任何地方使用，不必先申明再使用；
如果把函数申明用()或+ - !等修饰则变成函数表达式，且后面加()后即可立即执行；

---------------------------------------------------------------------------------------------------------------------------------------------
全站页面置灰方法CSS
html{
filter: grayscale(100);
}
-------------------------------------------------------------
js中this的绑定 https://www.cnblogs.com/echolun/p/11962610.html
1.默认绑定 函数调用无任何调用前缀对象(xx.fun())，在非严格模式下(在严格模式环境中，默认绑定的this指向undefined)，默认绑定this指定全局对象windows
2.隐式绑定 函数调用时前面存在调用它的对象，那么this就会隐式绑定到这个对象上
  如果函数调用前存在多个对象，this指向距离调用自己最近的对象；
  函数作为参数传递或将函数赋值给变量（隐式绑定丢失）实际上都是调用方都改变成被赋值的对象了如下 ：

//函数赋值给变量
var name ="bb";
function fn(){
  let name ="aa";
  console.log(this.name);
}
var fnA = fn; //将fn()赋值给fnA,调用者是fnA,则this为默认绑定指向的为windows 则结果为bb
fnA();
----------------------
// 函数作参数传递
var name = "bb"
var obj={
    name:'objname',
    fun:function(){
    		console.log(this.name);
    }
}

function fnC(params){
	params();
}
fnC(obj.fun); //将obj.fun函数传给funC来执行，执行者为funC,所以结果应当为 bb;


3.显式绑定。通过call apply及bind方法改变this的行为（函数能主动选择自己的上下文）备注：无法改变箭头函数上下文
注意，如果在使用call之类的方法改变this指向时，指向参数提供的是null或者undefined，那么 this 将指向全局对象
fn.call(obj);
fn.apply(obj);
fn.bind(obj)();

fn.call(null);
fn.call(undefined);
fn.apply();

js API内置显式绑定如
var obj={
	name:"test"
}
[1,2,3].forEach(function(){console.log(this.name)},obj);

4.new绑定，this指向new创建的对象
5.this绑定优化级
 显式绑定 > 隐式绑定 > 默认绑定
 new绑定 > 隐式绑定 > 默认绑定
6.箭头函数的this：箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁
  


============================================================
JS作用域链与原型链的区别：
当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象window，如果window都没有这个变量则报错。
当在对象上访问某属性时，首选i会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是null，如果全程都没找到则返一个undefined，而不是报错。
--------------------------------------------
var 与 let区别
1.var属于ES5范畴,let属于ES6
2.var有预处理机制，let没有。（预处理机制也就是常说的声明提前）　
  备注：声明提前：不管变量被声明在函数什么位置，所有变量声明都会被提升至函数顶部（变量声明指 var a; 即声明还未赋值
   即使在函数内部，声明变量时一定要加上var，不要只写 a = 1; 否则变量a会自动升为全局变量
3.作用域的不同，var是全局作用域，let是块级作用域 (let定义的变量只在{}里才能访问到)
　<script>
        if(true) {
            var let = 1;
        }
        console.log(a); //报错
    </script>
------------------------------------------------------------------------
call、apply与bind有什么区别？
1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，
	这也是为什么上方例子中bind后还加了一对括号 ()的原因。
2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。
3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，
	因为apply在执行时还要多一步解析数组。
	
apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.
=========================================================
js 模板
function fn(name){
	return `my name is :${name}`;
}

============================================================
js 原型链
Promise
eval

-----------------------------------------------------
javascript中的this指向问题：https://www.cnblogs.com/isaboy/archive/2015/10/29/javascript_this.html
函数是否是new进行调用 this 指向创建的对象
             是否使用.调用，是的话，指定.前面的对象，否则指向全局window
             
Arrow Function 词法作用域，没有this 所谓的词法作用域就是一个变量的作用在定义的时候就已经被定义好，当在本作用域中找不到变量，就会一直向父作用域中查找，直到找到为止。

JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因
“JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，
构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，
首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，
则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）
创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。
最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，
函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。”

-----------------------------------------------------------------------------------------------
js new 过程 https://www.cnblogs.com/echolun/p/10903290.html
在《JavaScript模式》这本书中，new的过程说的比较直白，当我们new一个构造器，主要有三步：
1 创建一个空对象，将它的引用赋给 this，继承函数的原型。
2 通过 this 将属性和方法添加至这个对象
3 最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象）

-------------------------------------------------------------------------------------------------
JS对象创建方法：
1.直接量创建（推荐方式）
let obj={name:'',age:12};
obj.method=function(){};
obj.name="";

let obj1={
	name:"xxx",
	method:function(){}
}

2.通过构造函数创建对象
let obj = new Object();
obj.name=""
obj.method=function(){}

3.自定义构造函数创建对象 //建议将所有实例都需要用到的属性添加在prototype上，因为这样在每次new时，不用每次新开内存时都创建一次
//第一，加在原型链上，new实例时不需要反复创建属性造成内存浪费，第二，简化构造函数的属性能减轻对不需要这些属性的实例的困扰，这也是原型链继承的好处
var Person = function(){
  // var this = {}; 创建一个空对象，将它的引用赋给this，继承函数的原型 准确来说是// var this = Object.create(Person.prototype);
	this.name = "xx";
	this.sayName=function(){  //new 一次sayName()方法会反复的被添加到this中，且每次sayName()方法都会在内存中新开内存
		console.log(this.name)
	}
	//return this; 这里隐性返回的其实就是上面创建的空对象，这个空对象被赋予了name属性和一个sayName方法
}
Person.prototype.sayname=function(){}  //解决上述内存占用问题，将方法添加至Person原型上

var p = new Person();
p.sayName();

4.利用构造函数模式实现多继承
function Cat () {
  this.legs = 4;
  this.say = function () {
    console.log('喵~')
  }
};
function Bird() {
  this.wings = 2;
  this.fly = true;
}
function CatWings() {
  Cat.apply(this);
  Bird.apply(this);
};
let miao = new CatWings();
console.dir(miao);

--------------------------------------------------
/**
 * 控制重复执行提交
 * @param {*} fn 需要执行方法
 * @param {*} delay 多久内执行有效
 */
function debounce(fn,delay){
    var timeout = null;
    var startDate = new Date();
    return function(){
        var endDate = new Date();
        clearTimeout(timeout);
        if(endDate-startDate>=delay){
           fn();
        }else{
            timeout = setTimeout(function(){
                fn();
            },delay)
        }
        startDate = endDate;

    }
}

var btn = document.getElementById("btn");
btn.addEventListener("click",debounce(function(){
    $.ajax({
        url:"",
        success:function(res){
            console.log(res)
        }
    })
},1000),false);

================================================
JS执行上下文：https://www.cnblogs.com/echolun/p/11438363.html
1.执行上下文有且只有三类，全局执行上下文，函数执行上下文，与eval上下文
1.1全局执行上下文 一般由客户端浏览器创建如 window对象，全局对象window上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，
同时window对象还是var声明的全局变量的载体。我们通过var创建的全局对象，都可以通过window直接访问

1.2 函数执行上下文

在执行上下文的执行阶段，进行变量对象的赋值，函数的引用等


函数形参，是指函数声明时定义在圆括号里的形式参数，不是一个确切值。
函数实参，是指函数调用时提供的实际参数，是一个确切值，arguments指向实参引用，这个没问题。

function fn(){
	console.log(arguments)；
}

---------------------------------
js 编码规范：https://www.cnblogs.com/echolun/p/11408779.html
js 执行上下文：
https://www.cnblogs.com/shaunyang/p/10337099.html
https://www.cnblogs.com/lishuxue/p/6558788.html

执行上下文
1.全局执行上下文（JS代码加载完毕后，进入代码预编译即进入全局环境）
2.函数环境执行上下文（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
3.eval执行上下文（不建议使用，会有安全，性能等问题）

执行上下文重要属性
1.变量对象：存储了在上下文中定义的变量和函数声明
2.作用域链(Scope chain)，和原型链类似，当查找变量时，会先在当前上下文变量对象中查找，如果没有会去父级上下文变量对象中查找，直到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链
3.this

执行栈（调用栈）
具有 LIFO（后进先出）用于存储在代码执行期间创建的所有执行上下文
首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶
栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文

创建过程
创建变量对象（创建arguments对象，检查函数申明，检查变量申明）
创建作用链 将当前作用域添加至作用链顶端
确定this指向 (全局上下文指向window 函数根据情况指向)

1.创建arguments对象，检查当前上下文中的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
2.函数声明。检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。(function声明会比var声明优先级更高一点)。
3.变量声明。检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

变量提升的原因：
在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。
所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。
从创建顺序看，函数提升优先于变量提升。


执行阶段：完成对所有变量的分配，最后执行代码
变量赋值
函数引用
执行其他代码

------------------------------------
理解this的第一步就是要明白：this既不指向函数自身，也不指向函数的词法作用域；

this是在运行时进行绑定的，而不是在编写时绑定，它的上下文取决于函数调用时的各种条件；

this的绑定和函数声明的位置没有任何关系，只取决于函数的调用位置和调用方式；

this绑定规则有4点：按优先级1到4判断

1.由new调用？绑定到新创建的空对象；

2.由call、apply、bind调用？绑定到指定的参数对象；如foo.call(obj)

3.由上下文对象调用？绑定到这个上下文对象；如obj.foo()

4.默认情况下绑定到全局对象，foo()；在严格模式下绑定到undefined；

========================================================
this指向总结：
this是运行时绑定的，全局函数中的this是window（严格模式undefined），而当函数作为某个对象的方法调用时，this就是指的那个对象
1.对象中普通函数中的this指向的是对象，对象函数中嵌套的返回的匿名函数（闭包）指向window，对象函数是箭头函数指向的window
2.对象函数中嵌套返回的箭头函数没有自已的this，其this指向外部函数（外部上下文的this指向）
3.通过new对象或构造函数中，普通函数箭头函数指向对象，对象函数中嵌套的返回的匿名函数（闭包）指向window
4.可以通过apply call bind修改this(箭头函数除外)
5.函数中嵌套返回匿名闭包函数时，可以先将this赋值给一个变量，然后闭包访问这个变量
如：
let obj={
	 name:"objname",
	 get:function(){
	 		var that = this;
	 	  return function(){
	 	  	console.log(that.name)
	 	  }
	 }
}























变量提升是将变量声明提升到它所在作用域的最开始的部分

javascript代码执行过程分两个阶段
1.代码编译阶段 将代码翻译成可执行代码
2.代码执行阶段（由引擎完成）执行上下文会在这个阶段创建，
执行上下文（执行上下文可以理解为当前代码的执行环境，它会形成一个作用域）的创建也分创建阶段 及执行阶段






当调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。
创建阶段：在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。
代码执行：创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。


执行上下文（Execution Context）代码被解析或执行所在环境的抽象概念，（JavaScript中的运行环境）
全局执行上下文（JS代码加载完毕后，进入代码预编译即进入全局环境）
函数环境执行上下文（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
eval执行上下文（不建议使用，会有安全，性能等问题）
当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，
而栈顶就是当前正在执行的上下文。处于栈顶的上下文执行完毕之后，就会自动出栈。

对于每个执行上下文，都有三个重要属性：
1.变量对象(Variable object，VO)，存储了在上下文中定义的变量和函数声明。在全局执行上下文中指window，函数执行上下文中就是活动对象（AO）
2.作用域链(Scope chain)，和原型链类似，当查找变量时，会先在当前上下文变量对象中查找，如果没有会去父级上下文变量对象中查找，直到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链



词法环境，变量环境
变量对象  活动对象


<pre> 标签可定义预格式化的文本。
被包围在 <pre> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。

throttle/debounce
Reactive Extension 也叫 ReactiveX,或者简称Rx,指的是实践响应式编程的一套工具。Rx是一个大家族它包含 RxJava、RxPy等，RxJS是Rx用JavaScript语言实现。
RxJS是Rx用JavaScript语言实现


npm init 
在node开发中使用npm init会生成一个pakeage.json文件

setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。

Angular父子组件间传值
1.@Input 父组件传值给子组件
子组件中定义接收变量
@Input
hero: Hero; 

父组件中使用
<子组件引用名 [hero]="父组件中需要传值变量"></子组件引用名>

 
 

2.@Output 子组件传值给父组件
父组件中使用
<子组件引用名 (eventName)="emiterFun($event)"></子组件引用名>如下：
<app-price-quote (lastPrice)="priceQuoteHandler($event)"></app-price-quote><br>
<div>这是在报价组件外部，<br>
股票代码是{{priceQuote.stockCode}},
股票的价格是{{priceQuote.lastPrice | number:'2.2-6'}}</div>

父组件中定义接收方法如下：
export class AppComponent {
  // aaa = "";
  priceQuote: PriceQuote = new PriceQuote("", 0);
  // 书写一个方法接收$event,这个event的类型就是字组件emit发射过来的类型
  priceQuoteHandler(event) {
    this.priceQuote = event;
  }
}

子组件定义@Output如下：
@Output
lastPrice:EventEmitter<PriceQuote> = new EventEmitter();

constructor(){
  new priceQuote();
	this.lastPrice.emit(需要传的值或对对象priceQuote);
}


linux ftp服务
1. 首先服务器要安装ftp软件,查看是否已经安装ftp软件下：
#which vsftpd
如果看到有vsftpd的目录说明服务器已经安装了ftp软件

2. 查看ftp 服务器状态
#service vsftpd status

3. 启动ftp服务器
#service vsftpd start

4. 重启ftp服务器
#service vsftpd restart

5. 查看服务有没有启动
#netstat -an | grep 21
tcp 0 0 0.0.0.0:21 0.0.0.0:* LISTEN
如果看到以上信息，证明ftp服务已经开启。

6.如果需要开启root用户的ftp权限要修改以下两个文件
#vi /etc/vsftpd.ftpusers中注释掉root
#vi /etc/vsftpd.user_list中也注释掉root
然后重新启动ftp服务。


===============================
nginx

whereis nginx

nginx -t  //查看nginx 默认配置文件目录

/usr/sbin/nginx  //安装目录

systemctl status nginx.service

/bin/systemctl start nginx.service
/bin/systemctl stop nginx.service
/bin/systemctl restart nginx.service

nginx -c xxx/nginx.conf  //不加-c 则使用默认配置文件启动


# nginx指定配置文件启动
/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf


1.首先利用配置文件启动nginx。
命令:nginx -c /usr/local/nginx/conf/nginx.conf
重启服务：service nginx restart
2快速停止或关闭Nginx：nginx -s stop
3.正常停止或关闭Nginx：nginx -s quit
4. 配置文件修改重装载命令：nginx -s reload


获取yum安装rpm包

yum -y install --downloadonly --downloaddir=./ openssh   //获取openssh rpm包至当前目录下，且不安装仅下载

rpm -ivh *.rpm --nodeps --force  // cd 至当前目录后安装所有rpm包 不清楚rpm包依赖关系

 rpm -qa|grep openssl  //查询openssl 安装情况
 
 
 
------------------------------------------
linux yum 安装
yum list java*  //列出所有可安装的JAVA版本

yum install -y java具体版本

#rpm -qa|grep java  //安装后检查安装版本
#rpm -ql jenkins  //查看yum安装的JENKINS文件

卸载一个软件时 
yum -y remove httpd
卸载多个相类似的软件
yum -y remove httpd*
卸载多个非类似软件时
yum -y remove httpd php php-gd mysql

这时候需要用wget命令去网络上下载资源包
wget?http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo?-O /etc/yum.repos.d/epel-apache-maven.repo
然后重新安装maven????? ：yum -y install apache-maven


windows openssh
1.ssh-keygen -t dsa|rsa  生成密钥 (会生成id_dsa, id_dsa.pub 私公密钥对)
2.将公钥复制至远程电脑 ~/.ssh/authorized_keys 中如下：
 cat id_dsa.pub >> ~/.ssh/authorized_keys
3.ssh user@ip 即可


修改 sshd 服务配置(可修改端口等)
vi /etc/ssh/sshd_config 

systemctl status sshd.service  //查看sshd 服务状态
systemctl restart sshd.service //重启sshd 服务


ssh -p 8920 -i C:\Users\fang_houjun\.ssh\id_rsa root@10.30.32.12 -t "pwd;ls"   //-t 'pwd;ls'  创建虚拟交互终端 并执行pwd ls后返回

sftp -P 8920 -i C:\Users\fang_houjun\.ssh\id_dsa root@10.30.32.12   //-i 指定私钥文件位置

%cd%  //获取当前执行目录
%A:B=C%  // dos中 A:B=C的方式来替换字符串，具体含义就是在字符串变量A中查找所有的子串B并且替换成子串C

-----------------------------------
Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
一、获取对象中属性描述对象
--Object.getOwnPropertyDescriptor(obj, propName)
参数：第一个参数是目标对象，第二个参数是目标对象的目标属性。
返回值：该属性描述对象
如：
const obj = {
    item: 'hello',
    msg:'hi'
}
Object.getOwnPropertyDescriptor(obj, 'item')
{
    value: 'hello',
    writable: true,
    enumerable: true,
    configurable: true
}

二、获取对象中全部属性的属性描述对象
--Object.getOwnPropertyDescriptors(obj)
参数：想要获取的对象
返回值： 描述对象集合

三、属性描述对象的定义
--Object.defineProperty(obj, propName, descriptorObj)
参数：第一个参数目标对象，第二个参数是属性名，第三个参数是属性描述对象。
返回值： 修改后的对象
const obj = Object.defineProperty({}, 'item', {
  item: 'hello',
  writable: true,
  enumerable: true,
  configurable: true
});

// 当然，这样定义只是为了定义描述对象。
// 直接
obj.item = hello   // 最终也和上面一样

obj.item // "hello"
---------------------------------------------------------------------------------
JavaScript.descriptor(属性描述符) 参考：https://blog.csdn.net/weixin_30252709/article/details/97676560


Object.assign 深度复制
方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。

========================================================
typeScript 装饰器 //AOP的好处了，把和主业务无关的事情，放到代码外面去做
动态扩展额外的功能
避免继承的方式可能会导致子类繁多
在不改变接口的前提下，增强类的性能

装饰模式以对客户透明的方式动态的给一个对象附加上更多的功能。并且，客户端并不会觉得对象在装饰前和装饰后有什么不同。
装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展
Decorator 就是一个的包裹函数


js class  JavaScript构造函数的语法糖 //它可以看作是构造函数穿上了统一的制服，所以class的本质依然是函数，一个构造函数
class的本质是构造函数class的本质是构造函数class的本质是构造函数!!

class的body部分包含在花括号{}中，这里是定义class成员的地方
constructor方法是一个特殊的方法，用来创建并初始化一个对象。在一个class中只能有一个命名为constructor的特殊方法，如果包含多个将会报错。
constructor中可以通过super关键字，调用父类的constructor方法。


参考：https://blog.csdn.net/zhq2005095/article/details/80715551
修饰器是一个对类进行处理的函数。用来修改类的行为。
注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。
1.类的修饰器函数的第一个参数 target 指向类本身

2.修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。类是不会提升的，所以就没有这方面的问题。

原文链接：https://blog.csdn.net/u010958922/java/article/details/53584956
function decorateArmour(target, key, descriptor) {
  const method = descriptor.value;
  let moreDef = 100;
  let ret;
  descriptor.value = (...args)=>{
    args[0] += moreDef;
    ret = method.apply(target, args);
    return ret;
  }
  return descriptor;
}
其中，target是需要修改的对象；key是对象中的值；descriptor包含着这个值的内容，包括value、是否可读、是否可遍历等。
例如Decorator用于一个类的函数上，那么target就是这个类、key就是这个函数名、descriptor.value就是这个函数。



// @param  target 作用对象
// @param  prop  作用的属性名
// @param  descriptor 属性描述符
// @return descriptor 属性描述符
function decorator(target,prop,descriptor){}


====================================
linux yum安装指定版本node

需要安装不同版本的node仅需要替换setup_8.x 成setup_9.x即可

curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -    
sudo yum -y install nodejs


卸载node
yum remove nodejs npm -y

curl --silent --location https://rpm.nodesource.com/setup_9.x | sudo bash -

==============================================================================
数据库设计：
1.概念模型 use case 用例图 用例图由参与者参与者（Actor）、用例（Use Case）、系统边界、箭头组成，用画图的方法来完成
2.逻辑模型 ER图是实体-关系图 实体 属性 关系（对概念模型具体化）
3.物理模型

UML 


=======================================================
\t 相当于tab
\r 回车换行（将光标置至行首）
\n 换行



String.format();

0	显示数字，如果位数不够则补 0
#	显示数字，如果位数不够不发生变化

new Decimalformat("####.000").format(111.12)  // 111.120



java 千分位的添加和去除

将一个数字转换为有千分位的格式
NumberFormat numberFormat1 = NumberFormat.getNumberInstance();  
System.out.println(numberFormat1.format(11122.33)); //结果是11,122.33  
  
NumberFormat numberFormat2 = NumberFormat.getNumberInstance();  
numberFormat2.setGroupingUsed(false); //设置了以后不会有千分位，如果不设置，默认是有的  
System.out.println(numberFormat2.format(11122.33)); //结果是11122.33   


将一个可能包含千分位的数字转换为不含千分位的形式：
String amount1 = "13,000.00";  
double d1 = new DecimalFormat().parse(amount1).doubleValue(); //这里使用的是parse，不是format  
System.out.println(String.valueOf(d1)); //结果是13000.00  


String currecy = NumberFormat.getCurrencyInstance().format(1245600000);
System.out.println("转换成Currency格式："+currecy);

//将一个千分位分隔的带货币类型的数字串转化成数值
try {
    long dd =  new DecimalFormat().parse(currecy,new ParsePosition(1)).longValue();
    System.out.println(String.valueOf(dd));
} catch (Exception e) {
    e.printStackTrace();
}

java 数字格式化处理（小数点 百分号等）：https://blog.csdn.net/liu552726/article/details/9332957?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase


===================================================
java 数组 数组长度一旦声明,不可改变不可追加

整型数组初始化：
静态初始化：
int[] array = new int[]{1,2};
int[] temp = {1,3};           //简化方式
int temp[] = {1,3};    //这种方式也可以

动态初始化：
int[] array;  //先声明
array = new int[10];

int[] temp = new int[10];//合成一步


int[] arr;
arr = new int[10];
arr[0]=1;

int[] aa = new int[]{1,2};  //

int[] bb = new int[2];

-----------------------------------------------------------

javap是jdk自带的反解析工具

-------------------------------
format->NumberFormat->DecimalFormat

java1.5之后出现 ... 可变长参数 相当于可传0-N个参数的数组如下：
public void test(String ...name)

----------------------------------------------
jconsole使用

java 
-Djava.rmi.server.hostname=10.160.13.111  #远程服务器ip，即本机ip
-Dcom.sun.management.jmxremote #允许JMX远程调用
-Dcom.sun.management.jmxremote.port=3214  #自定义jmx 端口号
-Dcom.sun.management.jmxremote.ssl=false  # 是否需要ssl 安全连接方式
-Dcom.sun.management.jmxremote.authenticate=false #是否需要秘钥
 -jar test.jar 
 
linux 防火墙：https://blog.csdn.net/wade3015/article/details/90725871


1、在$JAVA_HOME/bin 下创建一个新文件  jstatd.all.policy，编辑该文件，填入内容：
grant codebase"file:${java.home}/../lib/tools.jar"{ permission java.security.AllPermission; };//若没有配置 JDK 环境变量，file 后面添加 tool.jar 的绝对路径

2、启动命令，默认监听1099端口并给该文件加上执行权限 chmod +x jstatd.all.policy

jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=127.0.0.1

要使用 VisualGC 必须在远程机上启动jstatd代理程序

/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64/bin

jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.logCalls=true &

https://www.cnblogs.com/qq931399960/p/10960573.html


java \
 -Djava.rmi.server.hostname=172.16.100.61 \
 -Dcom.sun.management.jmxremote.port=1566 \
 -Dcom.sun.management.jmxremote.authenticate=true \
 -Dcom.sun.management.jmxremote.ssl=false \
 -jar bosent_baseline_hot-deploy-SPRINGCLOUD-pcmsworkflow-161102-08-0.1-executable.jar &
 
 
--------------------------------------
java 性能监控工具
jps:jvm process status tool:显示指定系统中所有的hotspot虚机进程
jstat:jvm statistic monitoring tool) 收集hotspot虚拟机各方面的运行数据
jinfo:configuration info for java :显示虚拟机配置信息
jmap:memory map for java :生成虚拟机的内存转储快照heapdump文件
jstack：stack trace for java :显示虚拟机的线程快照
jconsole jmx的可视化工具
visualvm 可视化工具

jmap(查看内存):可以输出所有内存中的对象工具，也可以将VM中的堆文件以二进制形式输出成文本。
jmap -heap <pid>  //打印出PID进程对应的JVM堆内存heap配置及堆内存使用情况

jmap -finalizerinfo pid  //打印出PID进程对应内存准备回收的对象信息

jmap -dump:live,format=b,file=mydump.txt pid  //将pid进程对应JVM的heap内容到指定文件中

jmap -dump:format=b,file=heap pid

获取堆dump
1.启动参数配置outofmemory时触发打印堆快照
-XX:HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xx/xx/

2.jvm 命令：
jmap -dump:format=b,file=xxx.hprof <pid>  

查看所有对象的数量以及大小包括类型：jmap -histo 14116 | more
查看所有对象的数量以及大小包括类型：jmap -histo:live 14116 | more



64位机上使用需要使用如下方式：
jmap -J-d64 -heap pid


获取thread dump
kill -3 PID > some.file 2>&1

jstack [option] pid >> jstack.info  //获取thread dump文件

或 jstack -l pid >>d.txt
线程dump反映的是java虚拟所有线程在某一时刻的状态相信息。当前活动线程的快照



jstack(查看线程)

jstat(性能分析) Java Virtual Machine statistics monitoring tool
参考：https://www.cnblogs.com/shilimaixiang/p/13034871.html

jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]

jstat -class pid   //查看内加载情况

jstat -gc  pid  2000 20 //GC信息统计 每2秒统计一次，统计20次
S0C：第一个幸存区的大小
S1C：第二个幸存区的大小
S0U：第一个幸存区的使用大小
S1U：第二个幸存区的使用大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
OC：老年代大小
OU：老年代使用大小
MC：方法区大小
MU：方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间

jstat -gccause pid    //输出百分比+最近两次GC事件原因
jstat -gcnew  pid   //新生代行为统计
jstat -gcold  pid   //老年代行为统计

jstat -gccapacity pid   //堆使用情况统计
NGCMN：新生代最小容量
NGCMX：新生代最大容量
NGC：当前新生代容量
S0C：第一个幸存区大小
S1C：第二个幸存区的大小
EC：伊甸园区的大小
OGCMN：老年代最小容量
OGCMX：老年代最大容量
OGC：当前老年代大小
OC:当前老年代大小
MCMN:最小元数据容量
MCMX：最大元数据容量
MC：当前元数据空间大小
CCSMN：最小压缩类空间大小
CCSMX：最大压缩类空间大小
CCSC：当前压缩类空间大小
YGC：年轻代gc次数
FGC：老年代GC次数

jstat -gcnewcapacity pid //新生代堆使用情况








当堆内存空间溢出时输出堆的内存快照。
加参数-XX:HeapDumpOnOutOfMemoryError

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/home/tomcat/logs/...

java.lang.OutOfMemo-ryError: Java heap space
也就是说当发生OutOfMemoryError错误时，才能触发-XX:HeapDumpOnOutOfMemoryError 输出到-XX:HeapDumpPath指定位置。

=============================================================================================================
jstatd
jstatd是一个rmi的server应用，用于监控jvm的创建和结束，并且提供接口让监控工具可以远程连接到本机的jvm 。jstatd位于 $JAVA_HOME/bin目录下
jstatd是一个监控 JVM 从创建到销毁过程中资源占用情况并提供远程监控接口的 RMI （ Remote Method Invocation ，远程方法调用）服务器程序，
它是一个 Daemon 程序，要保证远程监控软件连接到本地的话需要 jstatd 始终保持运行。

jmx
JMX：Java Management Extensions ，即 Java 管理扩展 , 是一个为应用程序、设备、系统等植入管理功能的框架。 JMX 可以跨越一系列异构操作系统平台、
系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用 。而Visual VM是通过 JMX 来和远程 Java 应用联系的


检查hostname -i 检查系统IP

服务器端启动jstatd 服务（java.home/bin目录下）：
./jstatd -J-Djava.security.policy=jstatd.all.policy \
-J-Djava.rmi.server.hostname=10.30.32.5 \
-J-Djava.rmi.server.logCalls=true &

[root@localhost bin]# ./jstatd -J-Djava.security.policy=jstatd.all.policy   //默认就是1099
./jstatd -J-Djava.security.policy=/root/jstatd.policy -p 2099   //指定端口2099

要使Java VisualVM 成功连接到远程服务器上，服务器端应该在 /etc/hosts 文件中把本机地址设为本机的 IP 地址。
使用 hostname -i 命令查看，如果显示的是 127.0.0.1 或者与本机实际 IP 不一致的话，需要把 /etc/hosts 文件中相应的地址改为本机实际 IP 。
[root@localhost ~]# jstatd -J-Djava.security.policy=/root/jdk1.8.0_144/bin/jstatd.all.policy -J-Djava.rmi.server.logCalls=true



备注：-J-Djava.rmi.server.logCalls 启用日志

jvisualvm 连接 jstatd 远程监控 jvm 或 Visual GC提示"不受此JVM支持“ 解决方案如下：
服务端启用jstatd时指定安全策略文件如下：

创建安装策略文件jstatd.all.policy：
grant codebase "file:${java.home}/../lib/tools.jar"{
 permission java.security.AllPermission;
};

或绝对路径：
grant codebase "file:/opt/jdk1.8.0_221/lib/tools.jar"{
 permission java.security.AllPermission;
};

启动后可通过如下方式连接测试：
jps -l rmi://10.30.32.5:1099  连接上指定服务器查看虚机进程



jconsole visualvm 用户密码设置
jdk\jre\lib\management\jmxremote.password.template 复制一份为jmxremote.password
cp -r jmxremote.password.template jmxremote.password
修改：去掉# 启用配置
monitorRole  QED
controlRole  R&D

修改文件权限：chmod 600 jmxremote.password

-------------------
jconsole 时需一定要加-Dcom.sun.management.jmxremote=true参数

java -Dcom.sun.management.jmxremote.port=6969 -Dcom.sun.management.jmxremote.ssl=false \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.pwd.file=/opt/jdk1.8.0_221/jre/lib/management/jmxremote.password \
-Dcom.sun.management.jmxremote.access.file=/opt/jdk1.8.0_221/jre/lib/management/jmxremote.access \
-Djava.rmi.server.hostname=10.30.32.5 \
-Dcom.sun.management.jmxremote=true \
-jar xxx.jar




visualvm 连接远程服务：
https://www.cnblogs.com/qq931399960/p/10960573.html
https://www.cnblogs.com/grey-wolf/p/9234780.html
https://blog.csdn.net/weixin_33910460/article/details/92958822?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase





启动后查看
netstat -lpnt|grep jstatd

jps





jmx连接
两种地址
1、ip:port
2、jmx service url (service:jmx:rmi:///jndi/rmi://192.168.3.15:9999/jmxrmi)
service:jmx:rmi:///jndi/rmi://localhost:7091/jmxrmi
service:jmx:rmi:///jndi/rmi://<hostname>/jmxrmi

java 连接代码
public static void main(String[] args) {
		String hostName = "192.168.88.106";
		int portNum = 10089;
		
		try {
			JMXServiceURL u = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" 
					+ hostName + ":" + portNum + "/jmxrmi");
 
			Map<String, Object> auth = new HashMap<String, Object>();
			auth.put(JMXConnector.CREDENTIALS, new String[] { "controlRole", "R&D" });
 
			JMXConnector c = JMXConnectorFactory.connect(u, auth);
		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
 
	}


=====================================================
GC时会暂停整个JAVA应用，普通GC 只是对年轻代进行垃圾回收，full的GC会对整个堆内存（包含老年代、年轻代）进行垃圾回收。system的GC显示调用GC。
full gc 只会在两个情况下发生：1）system.gc被显示调用时，会执行full gc。2）老年代的堆内存满时，会执行full gc。








-----------------------
jps -l //查看本机所有java进程pid

线程dump反映的是java虚拟所有线程在某一时刻的状态相信息。当前活动线程的快照

top // 查看占用CUP进程情况
top -H -p <pid> 或 top -Hp pid  //查看cpu占用高线程
print "x%\n" <pid>  转化pid成16进制以例dump文件中查找定位

jstack pid |grep -A 20 xxxx

---------------------------------------linux下如何定位代码问题-------------------------------
top获取进程id
获取线程消耗cpu最多的线程 top -Hp pid
printf "%x\n" pid 转化线程ID为16进制
jstack pid |grep -A 20 16进制id




1、先通过top命令找到消耗cpu很高的进程id假设是123

2、执行top -p 123单独监控该进程

3、在第2步的监控界面输入H，获取当前进程下的所有线程信息

4、找到消耗cpu特别高的线程编号，假设是123

5、执行jstack 123456对当前的进程做dump，输出所有的线程信息

6、将第4步得到的线程编号11354转成16进制是0x7b

7、根据第6步得到的0x7b在第5步的线程信息里面去找对应线程内容

8、解读线程信息，定位具体代码位置

-----------------------------分割线----------------------------------------------------------
获取线程dump信息 thread dump方法
方法一：jstack [option] pid
--参数
1. -F 强制打印堆栈
2. -m 打印java 和 native（C++） 堆栈信息  
3. -l 打印额外的信息，包括锁信息

方法二：
kill -3 pid

备注：查找JAVA进程：
jps 或 ps -ef|grep java



Java语言中的线程是依附于操作系统的线程来运行的，从本质上来说是本地线程在执行java线程代码，从JVM源码角度分析，在Java中创建线程是，
实际上创建一个os thread，这个os才是真正的线程实体。
关于jvm虚拟机线程创建感兴趣的可以参考该链接：https://www.jianshu.com/p/3ce1b5e5a55e

thread dump 包含信息(线程的状态和其执行堆栈)：
线程的名字，ID，线程的数量等。
线程的运行状态，锁的状态(锁被哪个线程持有，哪个线程再等待锁等)。
调用堆栈(函数的调用层次关系)。调用堆栈包含完整的类名，执行的方法，源代* 码的行数

守护进程：创建线程的时候可以设置线程是否是守护进程。
优先级：线程创建的时候设置线程的优先级，一般采用默认值
线程id（tid）：JVM给线程分配的id号
本地线程id（nid）：对应的os 线程的线程id，可以将16进制转换为10进制，在os中找到对应的线程
线程状态：这线程堆栈日志中，一个线程就waiting 状态和 runnale两种状态
线程内存地址：线程起始地址




free -h -s n //每N秒显示内存使用情况

------------------------------------
程序计数器（线程私有，每一个线程都有独立计算器；生命周期同线程的创建而创建，随线程结束而死亡）：每个线程在创建后，都会产生自己的程序计算器及栈桢，
程序计算器主要是用来存放执行指令偏移量及行号指示器，线程的执行及恢复都要依赖程序计数器。

java堆（oom故障发源地，所有线程共享）：存放实例对象，堆由垃圾回收集器自动回收，堆由各子线程共享使用。堆内存空间可以固定大小也可以运行时动态调整
-Xms256m(最小堆容量) -Xmx1024m（最大堆容量）JVM的Xms和Xmx设置成一样大小，一定程序上避免GC后调整堆大小带来额外压力。
当线程请求分配内存，但堆内存已满且内存已满且无法再扩展时就抛出OutOfMemoryErro.


堆分为两大块：新生代及老年代
新生代=1个Eden区+2个Survivor区（from区，to区）默认8:1:1

Young GC
Full Garbage Collection(Full GC)

当堆内存空间溢出时输出堆的内存快照。
加参数-XX:HeapDumpOnOutOfMemoryError

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/home/tomcat/logs/...

备注：
堆是所有线程共享
程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个

Metaspace(元空间) 前称JDK7及之前版本只有Hotspot才有Perm区（永久代）
outOfMemoryError 年老代内存不足。
outOfMemoryError:PermGen Space 永久代内存不足。
outOfMemoryError:GC overhead limit exceed 垃圾回收时间占用系统运行时间的98%或以上。
outOfMemoryError:java heap space 堆内存不足


JVM将内存根据分代策略将内存分为三层：新生代，老年代，永久代（非堆永久代）
新生代from to 复制算法，不产生内存碎片，保证永远有一个survivor space是空的，另一个非空的survivor space无碎片
每个对象在坚持过一次Minor GC之后，年龄就加1

分代的意义，提高GC效率
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生
设置两个Survivor区最大的好处就是解决了碎片化

新生代是 GC 收集垃圾的频繁区域

JVM主要管理两种类型的内存：堆和非堆

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据(线程私有)；
堆解决的是数据存储的问题，即数据怎么放、放在哪儿（堆所有线程共享）。




64位机上使用需要使用如下方式：
jmap -J-d64 -heap pid

内存分析工具(Memory Analysis Tool）或与jhat (Java Heap Analysis Tool)


-----------------------------------------------------------
方法区：
方法区和永久代的关系很像Java中接口和类的关系，永久代是Sun公司HotSpot虚拟机对虚拟机规范中方法区的一种实现方式

JDK1.8之前调节方法区大小：
-XX:PermSize=N //方法区（永久代）初始大小
-XX:MaxPermSize=N //方法区（永久代）最大大小，超出这个值将会抛出OutOfMemoryError 

JDK1.8开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本机内存。参数设置：
-XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小


栈JVM stack:栈是java 方法执行的内存模型
堆：java heap :所有的对象实例以及数组都要在堆上分配，此内存区域的唯一目的就是存放对象实例
堆结构：新生代（Eden区+2个Survivor区）  老年代   永久代（HotSpot有）


JVM运行时内存划分为：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区。可以简记为：一计两栈一堆一区

YGC 在新生代中进行，首先要清楚新生代的堆结构划分。新生代分为Eden区和两个Survivor区，其中Eden:from:to = 8:1:1 (比例可以通过参数 CXX:SurvivorRatio 来设定 )，这是最基本的认识。

--------------------------------
jvm 堆配置：

堆设置
-Xms:初始堆大小 默认为物理内存的1/64
-Xmx:最大堆大小 默认为物理内存的1/4
-Xmn:新生代大小 通过这个值也可以得到老生代的大小：-Xmx减去-Xmn

备注：
-Xss：栈大小，设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，
当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，
特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。
（栈中存放数据过多，大量递归 java.lang.StackOverflowError）

-XX:NewRatio:设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3
-XX:SurvivorRatio:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5??
-XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代
-XX:PermSize、-XX:MaxPermSize:分别设置永久代最小大小与最大大小（Java8以前）
-XX:MetaspaceSize、-XX:MaxMetaspaceSize:分别设置元空间最小大小与最大大小（Java8以后）
收集器设置
-XX:+UseSerialGC:设置串行收集器
-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行老年代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器
垃圾回收统计信息
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:filename
并行收集器设置
-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
并发收集器设置
-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
-XX:ParallelGCThreads=n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。
――――――――――――――――
java 堆与栈

栈解决的程序运行问题，即程序如何执行，或者说如何处理数据；
堆解决的是数据存储问题，即就是数据如何放、放哪儿
从软件设计角度分析，栈代表了处理逻辑，堆代表了数据，这样分开，使得处理逻辑更清晰
堆和栈的分离，使得堆的内容可以被多个栈共享（即多个线程访问同一个对象）
面向对象就是堆和栈的完美结合，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。
每当一个新的线程被创建时（线程结束，栈内存就释放了。不存在垃圾回收问题）。Java 虚拟机都会分配一个虚拟机栈，Java虚拟机栈是以帧为单位来保存线程的运行状态。Java栈只会有两种操作：以帧为单位进行压栈跟出栈

栈及堆的优缺点：
1.堆线程共享是一个运行时数据区，类的对象实例从中分配空间，不需要程序显示的释放内存空间，由垃圾回收来负责；堆可以动态分配大小，生命周期不用事先告诉编译器；由于动态分配内存，所以存取速度较慢。
2.栈线程私有的，栈主要存放一些基本的变量（int,short,char,long,byte,float,double,boolean）及对象句柄。栈的优点是存取速度比堆快，仅次于寄存器，缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性

java把内存划分为 栈内存及堆内存

变量在栈中分配内存，同时存放在堆中的数组或对象的引用变量也在存放在栈中。超出变量作用域后，java会自动释放掉栈中分配的内存空间
堆内存放new 创建的对象及组数，堆中分配的内存由GC来管理

备注：引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象






栈
栈桢：局部变量表，操作数栈，动态链接，方法出口
栈不存在垃圾回收，线程私有，生命周期根据线程，会StackOverflowError



备注：
java的数据类型分为两种：基本类型和引用类型。基本类型的变量保存的是原始值，
引用类型的变量保存的是引用值。引用值代表某个对象的引用，而不是对象本身，对象本身放在这个引用值所表示的地址的位置

运行时数据区（内存模型）

==========================================================================
通过visualVM程序监控JVM，JDK 1.6中自带的可视化监控工具，这个工具比较实用，功能也比较强大。可以监控线程信息，堆内存信息，
还可以实时导出堆信息以及强制GC。监控本地JVM直接启动该工具后就可以监控，远程监控需要启动jstatd和jrxml。

启动jstatd方法：新建jstatd.all.policy文件，添加如下内容，tools.jar包的路径根据实际情况修改：
grant codebase "file:/home/ndmc/tomcat/jdk/jre/lib/tools.jar" {
   permission java.security.AllPermission;
};

执行启动命令./jstatd -J-Djava.security.policy=jstatd.all.policy，默认端口为1099，后面可跟-p指定其他端口号
使用jrxml远程监控JVM的时候需要加上以下参数：
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=8849
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
-Djava.rmi.server.hostname=hostip
====================================================================
JVM管理的几个内存区域包括以下几个内存区域：

1、  方法区（包含运行时常量池 JDK1.7之前->permspace 永久代 JDK1.8 MetaSpace 元空间）：用于存储JAVA类信息、常量、静态变量。这个区域也可以发生垃圾回收，比如当一些类不在被引用时JVM可以卸载这个类，不过这种回收动作很少发生。另外所有线程都共享方法区，因此线程对方法区的访问被设计为线程安全的。

2、  虚拟机栈：JAVA虚拟机栈是线程私有的，每当启动一个新线程时，JVM都会为它分配一个JAVA虚拟机栈。没当线程调用方法时，JVM都会为虚拟机栈压入一个栈帧，该栈帧用于存储参数、局部变量、中间运算结果、方法出口等。

3、  本地方法栈：和虚拟机栈类似，只是他是专为JAVA中的Native方法服务。当线程进入本地方法后，它已经脱离的JVM的限制，甚至可以直接使用本地处理器中的寄存器。实际上本地方法的调用机制非常依赖于JVM的具体实现。

4、  堆：由JVM启动时创建，由所有线程共享，用于存放对象的实例。一般情况下它是JVM中管理的内存中最大的一块。绝大部分JVM内存问题都发生在这一块。

5、  程序计数器：同虚拟机栈一样，它也是线程私有，启动线程是创建。程序计数器的中保存的内容总是下一条将被执行的指令的地址。


这几个内存区域，除了程序计数器区域外，其他几个区域都有可能发生内存溢出问题。常见的内存溢出有两种：
1、方法区溢出。出现该问题时，JVM会报如下类似错误：java.lang.OutOfMemoryError : PermGenSpace ，Perm区的最大内存大小可以通过-XX:MaxPermSize=指定。引起这类内存溢出原因一般有两个，一个是常量池太大，一个是需要加载的CLASS类太多。出现问题的时候排查下这两种可能性，问题可以很快找到。这类问题程序稳定后也很少出现。
2、堆内存溢出。在JVM可使用的最大堆内存可以在启动的时候通过-Xmx参数指定。堆内存溢出是最为常见的内存溢出问题，发生堆内存溢出时，JVM会报告如下错误：java.lang.OutOfMemoryError : java heap space。
这里列举下在定位堆内存溢出时，常见的方法和思路。堆内存溢出顾名思义就是，堆内存不够用了，如果程序设计的最大对内存已经耗尽，那说明程序设计存在问题，不该申请很多内存的逻辑申请了很多的内存，该释放的对象没有释放。最重要的问题是就要要找出到底是什么对象没有及时释放，导致占用了过多的内存。常见的方法：
a、  一个强大的定位工具是使用 jprofiler，通过jprofiler可以实时的监控到，当前的堆内存的总体使用情况及当前存活的对象、大小、分配树、对象引用链等等，功能非常全面


---------------------------------------------------------
常见内存溢出问题：
java.lang.OutOfMemoryError: Java heap space 堆内存溢出
java.lang.OutOfMemoryError: PermGen space  方法区内存溢出
java.lang.OutOfMemoryError: GC overhead limit exceeded  垃圾回收时间占用系统运行时间的98%或以上 //GC占用了多余98%（默认值）的CPU时间却只回收了少于2%（默认值）的堆空间


在 JDK 1.7 之后(包括1.7)，字符串常量池已经从方法区移到了堆中

Java是使用 双亲委派模型 来进行类的加载的
双亲委托模型的工作过程是：　　

　　如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，
　　而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的
　　启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，
　　子加载器才会尝试自己去加载。

使用双亲委托机制的好处是：
　　能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。

三种JVM
hotspot(Sun公司),JRockit(BEA公司的JRockit),J9VM(IBM公司)

JDK包含JRE包含JVM

-----------------------------------------------
栈：存放基本类型变量，对象引用变量；（栈帧：局部变量表，操作数栈，动态链接，方法出口）
堆：存放有new创建的对象和组数
小结：堆是来存放对象，栈是用来执行程序的

方法区：跟堆一样被所有线程共享，主要存放类信息，常量，静态变量
程序计数器：字节码执行指令地址

符号引用
在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类要引用org.simple.Tool类，
在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 
的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址.

volatile修饰变量。在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

类从被加载到内存中开始，到卸载出内存为止。它的生命周期总共七个阶段：加载---->验证---->准备---->解析---->初始化---->使用---->卸载
符号引用将在解析阶段被替换为直接引用

Java6和6之前，常量池是存放在方法区（永久代）中的。
Java7，将常量池是存放到了堆中。
Java8之后，取消了整个永久代区域，取而代之的是元空间。运行时常量池和静态常量池存放在元空间中，而字符串常量池依然存放在堆中。


========================================================================================================
JVM:java virtual machine  java虚拟机，一种软件实现，整个JAVA的实现跨平台运行的核心部分；可以运行class格式的类文件，JVM屏蔽了平台，使java程序只运行在各自平台的虚机上，从而实现
一个CLASS文件跨平台运行。

JDK->JRE-JVM  java开发工具包-》java运行环境-》java虚拟机

jvm实例 对应一个独立运行的JAVA程序 每个java程序都运行它自己的jvm实例，当一个java程序启动时，一个jvm实例诞生，当该程序关闭时，jvm实例随之消亡。

CLASS文件（Byte-code字节码文件）：各种不同平台的虚拟机和平台都统一使用一种存储格式-字节码，是和平台无关的基石
class文件是一组以8位字节为基础单位的二进制流，class文件并不是机器语言而是二进制文件（机器语言指的是硬件能直接运行的二进制指令代码）


常量池存放内容：
1.字面量： 文本字符串，申明为final的常量值
2.符号引用：
 类和接口的全限定名
 字段名称和描述符
 方法名称和描述符


------------------
2.5. Run-Time Data Areas
2.5.1. The pc Register
2.5.2. Java Virtual Machine Stacks
2.5.3. Heap
2.5.4. Method Area（包含Run-Time Constant Pool）
2.5.5. Run-Time Constant Pool
2.5.6. Native Method Stacks
-----------------------------------------


Class类文件的结构
１.无符号数
２.表
无符号数属于基本的数据类型:
u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节，8个字节的无符号数。
表是由多个无符号数或者其它表作为数据项构成的复合数据类型，以_info结尾


JVM Class字节码文件格式：
ClassFile {
    u4 magic;    //4个字节 CAFFBABE
    u2 minor_version; //2个字节 次版本号
    u2 major_version; //2个字节 主版本号45开始jdk1.1  46 jdk1.2
    u2 constant_pool_count; //2个字节 常量池容量
    cp_info constant_pool[constant_pool_count-1]; //常量表 从下标1开始，0为不使用常量
    u2 access_flags; 
    u2 this_class; 
    u2 super_class; 
    u2 interfaces_count; 
    u2 interfaces[interfaces_count]; 
    u2 fields_count; 
    field_info fields[fields_count]; 
    u2 methods_count; 
    method_info methods[methods_count]; 
    u2 attributes_count; 
    attribute_info attributes[attributes_count]; 
}

JVM 常量池类型
类 型															标 志	描 述
CONSTANT_utf8_info								1	UTF-8编码的字符串
CONSTANT_Integer_info							3	整形字面量
CONSTANT_Float_info								4	浮点型字面量
CONSTANT_Long_info								5	长整型字面量
CONSTANT_Double_info							6	双精度浮点型字面量
CONSTANT_Class_info								7	类或接口的符号引用
CONSTANT_String_info							8	字符串类型字面量
CONSTANT_Fieldref_info						9	字段的符号引用
CONSTANT_Methodref_info						10	类中方法的符号引用
CONSTANT_InterfaceMethodref_info	11	接口中方法的符号引用
CONSTANT_NameAndType_info					12	字段或方法的符号引用
CONSTANT_MethodHandle_info				15	表示方法句柄
CONSTANT_MothodType_info					16	标志方法类型
CONSTANT_InvokeDynamic_info				18	表示一个动态方法调用点

常量
cp_info{
	u1 tag  //JVM通过tag位确定该常量池项表示什么类型的符号引用
	info[] //若干字节组成的info数组 可以是数值 也可以是索引
}

CONSTANT_Methodref_info { 
    u1 tag; 
    u2 class_index;  //表示引用这个方法的对象在常量池数组中的索引
    u2 name_and_type_index; //表示方法类型及名称在常量池数组中的索引
}

CONSTANT_Class_info {
     u1 tag; 
     u2 name_index; //类名称在常量池数组中的索引
}







一个线程--》表示一个JAVA虚拟机栈；
方法的执行--》可以通过压栈的方式--》方法对应栈帧

-------------------------------
类加载:
类加载器：
系统类加载器（应用类加载器）
可扩展类加载器
根类加载器

双亲委派机制，保证类的安全！
所有类的加载都会委托父类直到最顶层，在顶层开始寻找有没有这个类，如果有这个类就直接加载这个类；没有，就向下查找，直到找到位置。



JNI:java native interface java本地方法接口
native


ORM一般指对象关系映射。对象关系映射（Object Relational Mapping，简称ORM）


类加载过程：装载（查找类文件） 链接（验证，准备，解析：将CLASS文件的符号引用转化为直接引用） 初始化 使用 卸载



Linux scp 命令用于 Linux 之间复制文件和目录。

从远程复制到本地
scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 

从本地复制到远程
scp local_file remote_username@remote_ip:remote_folder 
或者 
scp local_file remote_username@remote_ip:remote_file 
或者 
scp local_file remote_ip:remote_folder 
或者 
scp local_file remote_ip:remote_file 
-----------------------------------------------------
java -jar myapp.jar --spring.profiles.active=dev




-------------------------------------------------------------
jmm 相关参考：
http://www.blogjava.net/DLevin/archive/2011/09/05/358033.html
https://blog.csdn.net/weixin_42762133/article/details/103241439

在sun提供的hotSpot虚拟机中，包括了启动类装载器、扩展类装载器、系统类装载器、用户定义类装载器

当遇到new（使用new关键字实例化对象）、getstatic（读取一个类的非final修饰静态字段）、putstatic（设置一个类的静态字段）、invokestatic（调用一个类的静态方法）方法时，
对相应的类执行初始化操作
解析阶段是JVM将常量池内的符号引用替换为直接引用的过程（此时与验证阶段存在交叉关系）

一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址


访问权限修饰符：https://blog.csdn.net/qq_37499840/article/details/89218587

final―终态类，表示该类不能被继承

成员变量修饰符
    public（公共访问控制符）: 指定该变量为公共的，他可以被任何对象的方法访问。

    private（私有访问控制符）: 指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。

    protected（保护访问控制符）: 指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。

    friendly: 在同一个包中的类可以访问，其他包中的类不能访问。

    final: 最终修饰符，指定此变量的值不能变。

    static（静态修饰符）：指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。

    transient（过度修饰符）：指定该变量是系统保留，暂无特别作用的临时性变量。

    volatile（易失修饰符）：指定该变量可以同时被几个线程控制和修改。

方法修饰符
    public（公共控制符）

    private（私有控制符）: 指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）

    protected（保护访问控制符）：指定该方法可以被它的类和子类进行访问。

    final:指定该方法不能被重载。

    static：指定不需要实例化就可以激活的一个方法。

    synchronize: 同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。

    native：本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。



public class A{
  static{
  	System.out.println("static init!")
  }
}

Class.forName("A",true,this.getClass().getClassLoader()) 等同 Class.forName("A") 等同 new A() 加载类并初始化
总结：
 不初始化则不会执行static块
 Class.forName("A",false,this.getClass().getClassLoader())   //加载类A 但不初始化，不会执行static

===========================================================
jvm 运行时数据区
线程共享: 方法区，堆内存
线程私有: 虚拟机栈，本地方法栈，程序计数器

加载信息至 方法区：类信息，运行时常量池，字符串常量

方法区存放信息：类信息，常量，静态变量，即时编译器编译后的代码缓存，域信息，方法信息等
主要用来存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

程序计数器
线程私有
JVM规范中唯一没有规定OutOfMemoryError情况的区域　　
如果正在执行的是Native 方法，则这个计数器值为空

类信息包括：
类型
域（field属性信息）
方法

类成员变量
final static 类常量（全局常量）
static  类变量

初始化的区别：初始化的时间不同，non-final的类变量在类加载的第二个阶段(链接阶段)的准备阶段被赋默认的初始值，
然后再类加载的第三个阶段(初始化阶段)被显示初始化（也就是赋值为代码中写的值）。
比如: 定义一个成员变量a, public static int a = 7; a在链接阶段的准备阶段被赋默认值0；然后再初始化阶段被显示初始化为7。

final的类变量是在编译阶段就被显示初始化了。
比如：定义一个成员变量， public static final int a = 7; a在代码被编译成字节码文件的时候就被赋值为7了。

JDK7之前 字符串常量存放在永久带（perm区 方法区）
JDK7开始 字符串常量池迁移至堆中

常量池共三类：
1.运行时常量池；
2.Class文件常量池；
3.字符串常量池。

一.常量池（Constant Pool，class文件常量池）java经过编译后生成的.class文件，class文件的资源仓库；主要存放字面量（文本字符串，final常量）和符号引用（类和接口的全局定名，字段的名称和描述，方法的名称和描述）
二.运行时常量池：方法区的一部分，用于存放编译期间生成的字面量及符号量，在类加载之后，存入运行时常量池；运行时常量池期间也有可能加入新的常量（如：String.intern方法）
三.String常量池：为减少字符串对象的重复创建，在堆中开出一段存放字符串。

常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
1.节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间
2.节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等

常量池的作用

一个java源文件的类，接口，编译后产生一个字节码文件。而java中字节码需要数据支持，通常这种数据会很大以至于不能直接存储在字节码里，换一种方式，可以存储到常量池里。

运行时常量池

（1）运行时常量池是方法区的一部分，常量池表是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载存放到方法区的运行时常量池中。

（2）运行时常量池创建时机：在加载类和接口到虚拟机后，就会创建对应的运行时常量池

（3）jvm为每一个已加载的类型（类或者接口）都维护一个常量池，池中的数据项和数组项类似，使用索引访问

（4）运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换成真实地址

（5）运行时常量池类似于传统编程语言的符号表，但是它所包含的数据比符号表更加丰富

（6）当创建类或者接口的运行时常量池，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则jvm会抛出OutOfMemoryError异常。

（7）运行时常量池具备动态性，比如使用String类的intern方法加入运行时常量池中


所有的方法中的普通变量都是在栈中的局部变量表中
final修饰的引用的地址和final修饰的基本数据类型都会放在常量池，常量池位于方法区中

栈中保存基本数据类型的变量和自定义的对象的引用(不是对象)，对象本身都存放在堆区中，被执行的方法的也是pull到栈中，当方法执行完后再push出栈



=========================================================

mysql 查询所有表
select table_name,table_rows,table_comment from information_schema.tables where table_schema='product_dev' order by table_rows desc;


统计所有表的数据量情况
select * from survey
select concat(
'select "',
TABLE_name,
'", count(*) from ',
TABLE_SCHEMA,
'.',
TABLE_name,
' union all'
) from information_schema.tables
where TABLE_SCHEMA='product_dev';

==================================================================================
方法区: 存放JVM加载的类信息，静态变量，常量即时编译器编译生成的代码等数据
在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识

String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池


1.运行时数据区域: 在运行时数据区里存储类Class文件元数据(方法区),对象和数组(堆)，方法参数局部变量(栈)等。
2.垃圾回收机制: java 语言的优势之一就是它的自动内存管理，主要回收运行时数据区域的堆内存里的数据
3.类加载机制: 虚拟机首先需要把编译完成的字节码文件通过类加载器来加载到运行时数据区域

每个栈帧都由局部变量表，操作数栈，动态链接组成的
动态链接的作用就是将符号引用转换为直接引用

StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。
OutOfMemoryError：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。


堆内存不足：OutOfMemoryError:java heap space
方法区内存不足：java8以前（java.lang.OutOfMemoryError:PermGen space）或者java8以后（java.lang.OutOfMemoryError:Metaspace）

jdk7以前，方法区的实现是永久代，jdk8开始方法区的实现使用元空间取代了永久代。
元空间和永久代最大的区别是：元空间不在虚拟机设置的内存中，而是使用本地内存




一.类加载或类初始化：当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接（验证，准备，解析）、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤。

二.类加载时机: 
1.创建类的实例，也就是new一个对象
2.访问某个类或接口的静态变量，或者对该静态变量赋值
3.调用类的静态方法
4.反射（Class.forName("com.lyj.load")）
5.初始化一个类的子类（会首先初始化子类的父类）
6.JVM启动时标明的启动类，即文件名和类名相同的那个类   


三.类class文件常量池 CONSTANT_Utf8_info存放数据：
1.当前类的全限定名；
2.方法字段名称；
3.方法字段描述符；
4.本类引用其他类全限定名，方法及字段名称及描述符
5.程序中的字符串常量
6.当前类的直接父类全限定名；
7.当前类型所实现或继承的所有接口的全限定名；
8.当前类文件中属性相关的字符串如属性名


class文件常量池数据项数据类型：
CONSTANT_Utf8_info（tag+leng+bytes）：存储的是一个常量字符串（源文件中的各种字符串）
CONSTANT_NameAndType(tag+nameindex+descriptorindex):字段或方法的名称符号引用（方法或字段的名称+方法或字段的描述符）
CONSTANT_Fieldref_info就是对一个字段的符号引用， 这个符号引用包括两部分， 一部分是该字段所在的类， 另一部分是该字段的字段名和描述符。 这就是所谓的 “对字段的符号引用” 


.class文件（字节码文件）常量池格式介绍：参考：https://blog.csdn.net/brave2211/article/details/21487287

常量池中除了存放一些字符字面量，还存放以下几种符号引用
（1） 类和接口的全限定名  源文件中一个类的名字， 在class文件中是用全限定名表述 例如， Object类在class文件中的全限定名是 java/lang/Object
（2） 字段的名称和描述符  字段名称+类型
（3） 方法的名称和描述符  方法名称+类型

1.类的全限定名（包+类名 换点换成反斜杆如java/lang/Object）

2.描述符（字段及方法在class文件中的描述符）
2.1 基本类型+void对应在CLASS文件中的描述符：
基本数据类型和void类型	类型的对应字符[long->J,boolean->Z,其他类型首个字母大写]
byte										B
char										C
double									D
float										F
int											I
long										J
short										S
boolean									Z
void										V

2.2 引用类型（类，接口，枚举，数组） 对应的CLASS文件中的描述符
	类："L" + 类型的全限定名 + ";"
	数组：若干个"["  +  数组中元素类型的对应字符串
	方法：(参数1类型 参数2类型 参数3类型 ...)返回值类型  //中间无空格

类："L" + 类型的全限定名 + ";"
Ljava/lang/Object;

数组：若干个"["  +  数组中元素类型的对应字符串 
int[]类型的对应字符串是： [I  
int[][]类型的对应字符串是： [[I 
Object[]类型的对应字符串是： [Ljava/lang/Object; 
Object[][][]类型的对应字符串是： [[[Ljava/lang/Object; 

2.3方法描述符：(参数1类型 参数2类型 参数3类型 ...)返回值类型
方法描述符									方法声明
()I													int getSize()
()Ljava/lang/String;				String toString()
([Ljava/lang/String;)V			void main(String[] args)
()V													void wait()
(JI)V												void wait(long timeout, int nanos)
(ZILjava/lang/String;II)Z		boolean regionMatches(boolean ignoreCase, int toOffset, String other, int ooffset, int len)
([BII)I											int read(byte[] b, int off, int len )
()[[Ljava/lang/Object;			Object[][] getObjectArray()

3.特殊方法名（指类的构造方法及类的静态初始化方法或块）
类的构造方法名----->  <init>         <init>:()V   //名称+方法描述符
静态初始化方法名--->  <clinit>
普通方法名--------->  两边相同


CLASS字节码文件结构
类型	名称	数量
u4	magic	1            //魔数
u2	minor_version	1    //次版本号
u2	major_version	1		 //主版本号
u2	constant_pool_count	1  //常量池数量
cp_info	constant_pool	constant_pool_count - 1
u2	access_flags	1
u2	this_class	1  //对当前类的描述
u2	super_class	1  // 对当前类的超类的描述
u2	interfaces_count	1  //当前类直接实现的接口的数量或当前接口直接继承的接口的数量
u2	interfaces	interfaces_count //对当前类或当前接口直接实现或继承的所有接口的描述
u2	fields_count	1  //字段数据
field_info	fields	fields_count  //描述的是当前的类中定义的字段的个数， 注意， 这里包括静态字段， 但不包括从父类继承的字段
u2	methods_count	1
method_info	methods	methods_count //这里包括静态方法， 但不包括从父类继承的方法 编译器可能会在编译时向class文件增加额外的方法， 也就是说， class文件中的方法的数量可能多于源文件中由用户定义的方法。 举例来说： 如果当前类没有定义构造方法， 那么编译器会增加一个无参数的构造函数<init>； 如果当前类或接口中定义了静态变量， 并且使用初始化表达式为其赋值， 或者定义了static静态代码块， 那么编译器在编译的时候会默认增加一个静态初始化方法<clinit> 。 
u2	attribute_count	1
attribute_info	attributes	attributes_count  //非实际类属性 class文件中的属性， 可以看做是存储一些额外信息的数据结构

U4 0XCAFFBABE  
u2 
u2 主版本号
常量池 
this_class    
super_class   
interfaces_count    
interfaces  


总结：
只有引用了一个方法或字段，常量池中才会存在和它对应的CONSTANT_NameAndType_info ， 如果只在当前类中定义了一个字段而不访问它， 
或者定义了一个方法而不调用它， 那么常量池中就不会出现对应的CONSTANT_NameAndType_info 数据项
 
java源码中没有显示调用的方法或变量，则常量池中不会存在对应的CONSTANT_NameAndType_info项,仅Utf8 存放的方法名或常量（符号引用）
class文件常量池中


jvm加载class文件至方法区
在jvm方法区中，一个class或interface是由其全限定名称和真正加载该类或接口的类加载器（即the defining classloader）来唯一确定的，因为一个类（如果无特殊说明，“类”表示class或interface，下同）可以由不同的类加载器加载。
Class的static变量是存储在Field data中，而final static则存储在Run-time constant pool中，Code的JVM指令存储在Method data中
Class Data中还有两个引用：一个是指向“the defining loader”的引用，该引用在Class的动态链接解析时需要用到，如果该Class中引用了其他类，那么在动态链接解析时，就用该类的“the defining loader”去找其他类，完成其加载、链接、初始化动作；另一个是指向Class实例（即java.lang.Class对象）的引用，而JDK提供java.lang.Class出来，这样java开发者就可以通过该引用获取到存储在method area中的Class Data

 给Class static变量分配内存空间，初始化为默认值即将内存空间清零。
 
JVM指令后面的#index表示ClassFile中常量池“数组”的索引，实际上线程中每一个函数的执行都对应一个帧在JVM Stack中的压入弹出
main函数是JVM指令执行的起点，JVM会创建main线程来执行main函数，以触发JVM一系列指令的执行，真正地把JVM run起来。在创建main线程时，
会为其分配私有的PC Register、JVM Stack、Native Method Stack


当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法
类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化


CLASS文件常量池下标从1开始：下标0存在的意义就是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达"不引用任何一个常量池项目"的意思


  笔记8提到了类静态成员变量的访问方式，但静态成员变量存储在哪里呢？在网上查阅不少资料，发现好多内容都是过时的了，其中主流观点是静态成员变量存放在方法区。JDK8之前，静态成员变量确实存放在方法区；但JDK8之后就取消了“永久代”，取而代之的是“元空间”，永久代中的数据也进行了迁移，静态成员变量迁移到了堆中（方法区是JVM的规范，永久代是方法区的具体实现）。
  
  
  严格来说,是1.8之后的元空间扮演了和之前方法区一样的角色。之前的方法区不但存储了类，接口等信息,还存储了静态变量，常量等信息。但是1.8之后把静态变量,常量这些信息都存在了堆空间中，元空间只有类信息，方法信息。
  
  
 静态变量+常量+类信息+运行时常量池存在方法区中，实例变量存在堆内存中。
 基本类型的变量和对象的引用变量都是在函数的栈内存中分配。
 
三种JVM
Sun公司的HotSpot；
BEA公司的JRockit；
IBM公司的J9 JVM；

Runtime data area 运行数据区详解（栈管运行，堆管存储）：

class文件由以下部分组成：
结构信息。包括class文件格式版本号及各部分的数量与大小的信息
元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池
方法信息。对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息



1.初始化代码执行顺序是：父类静态→子类静态→父类普通代码块→子类普通代码块→父类构造方法→子类构造方法
2.静态方法属于类不属于对象；静态方法中只能访问其他静态方法和静态数据，不能访问非静态的。
3.静态不可用this调用。

-------------------------------------------
方法区：虚拟机规范定义的，所有线程共享的内存区域，用于存储类型信息的(类的描述信息)。
主要存放已被虚拟机加载的类信息（类的字段方法）、常量、静态变量、即时编译器编译后的代码等数据。
永久代，metaspace是对方法区的实现
hotspot实行分代管理内存（新生代，老年代，永久代）
JDK8实现方法区用metaspace 堆外内存


Java类加载器基于三个机制：委托、可见性和单一性。
（1）委托机制是指加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或加载这个类，那么再加载它。
（2）可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。
（3）单一性原理是指一个类仅被加载一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。

BootStrap Loader（引导类加载器） ----- 负责加载系统类
ExtClassLoader（扩展类加载器） ----- 负责加载扩展类
AppClassLoade（应用类加载器）r ----- 负责加载应用类

jvm 数据类型
基本类型包括：byte,short,int,long,char,float,double,Boolean,returnAddress
引用类型包括：类类型，接口类型和数组。

栈上的引用(reference)指向的是堆里面的实例(instance)，而实例持有一个引用指向题中所说的Class对象
而这个Class对象是 java.lang.Class 的一个实例

age：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。
由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因

对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

面向对象定义之中，也规定了一些基本的特征：
（1）封装：保护内部的操作不被破坏；
（2）继承：在原本的基础之上继续进行扩充；
（3）多态：在一个指定的范围之内进行概念的转换。

对于面向对象的开发来讲也分为三个过程：OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程）
类是对象的模板，对象是类的实例
类属于引用数据类型，引用数据类型需要内存的分配和使用。所以，关键字new的主要功能就是分配内存空间

关键字new，都表示要分配新的堆内存空间，一旦堆内存空间分配了，里面就会有类中定义的属性，并且属性内容都是其对应数据类型的默认值
垃圾：指的是在程序开发之中没有任何对象所指向的一块堆内存空间，这块空间就成为垃圾，所有的垃圾将等待GC（垃圾收集器）不定期的进行回收与空间的释放

Java的锁状态其实可以分为三种，分别是偏向锁，轻量级锁和重量级锁
在Java HotSpot VM中，每个对象前面都有一个class指针（JVM通过Klass Word来判断该对象是哪个class的实例）
和一个Mark Word（用来存储对象的运行时数据比如：hashcode，GC分代年龄，锁状态，持有锁信息，偏向锁的thread ID）。 
Mark Word存储了哈希值以及分代年龄和标记位等，通过这些值的变化，JVM可以实现对java对象的不同程度的锁定

其中锁标记的值分别是：无锁=001，偏向锁=101，轻量级锁=000，重量级锁=010。

CAS（Compare-And-Swap 或 compare and exchange）是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,
并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题
CAS的底层实现就是lock cmpxchg，多核才会加锁，单核不需要	

CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做

版本号机制和CAS算法就用到乐观锁

数据表中除了数据还有一个version字段，更新数据时version字段会加一，
假设线程A在读取数据和version(version = 1)的期间，有另一个线程B也读取了version(version = 1),
线程A修改数据，更新version(version = 2),提交更新时，在更新version前读取的version(version = 1)和当前数据表中的version(version = 1)相同，则更新成功
线程B也修改数据，更新version(version = 2)提交更新时，由于读取时version = 1 而当前数据表version = 2 不相等，则更新失败，

CAS 是什么？
CAS(compare and swap) 比较并交换，有三个操作数，内存地址V ，预期值B，要替换得到的目标子A；
CAS指令执行时，比较内存地址V与预期值B是否相等，若相等则将A赋给B，（不相等则会循环比较直到相等）整个比较赋值操作是一个原子操作；
CAS有三个缺点
1，CAS自旋操作：当内存地址V与预期值B不相等时会一直循环比较直到相等，
2，只能保证一个共享变量的原子操作，
3，出现ABA问题：如果内存值初V次读取的时候为A，在将要赋值的时候再次检查还是A，能说明V没有改变过吗？
有一种可能时当读取内存值V的时候时A，有一个线程将A改为B，后有改为A，CAS会误认为内存值V没有改变，这称为CAS操作的ABA问题；

乐观锁、悲观锁是一种思想，CAS是乐观锁的一种实现。前者是非阻塞同步，非独占，而后者是阻塞同步，独占锁。在可预知的情况下，
如果竞争冲突发生较少，乐观锁是个不错的选择。而如果竞争激烈，悲观锁应得到考虑。

因为CAS采取失败重试的策略，所以不确定会发生多少次循环重试。如果在竞争激烈的环境下，其重试次数可能大幅增加。此时效率也就降低了
======================================
java CAS原理
volatile :https://mp.weixin.qq.com/s?__biz=MzI4MDYwMDc3MQ==&mid=2247486266&idx=1&sn=7beaca0358914b3606cde78bfcdc8da3&chksm=ebb74296dcc0cb805a45ca9c0501b7c2c37e8f2586295210896d18e3a0c72b01bea765924ce5&mpshare=1&scene=24&srcid=&key=c8fbfa031bd0c4166acd110fd54b85e9b3568f80a3f4c2d80add2f4add0ced46d1d3a0cf139c0ca64877a98635727a7fc593b850f8082d1fcf77a5ebf067fc1476285146d13d691f80b64b930006a341&ascene=0&uin=MjYwNzAzMzYzNw%3D%3D&devicetype=iMac+MacBookAir6%2C2+OSX+OSX+10.14.2+build(18C54)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=hbg9AwR77rok2jxxdwyHyTHBDzwwC7lR8aEfF6HfW4KgJwsj0ruOpw8iNsUK%2B5kK



*CountDownLatch和CyclicBarrier区别：
1.countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次
2.CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用

//参数count为计数值 构造器
public CountDownLatch(int count) {  };  

//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException { };   
//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  
//将count值减1
public void countDown() { };  


第一种，static的，作为类信息在类被加载时被存在静态的方法区，没毛病。
第二种，非static的，作为对象属性，在对象创建的时候被初始化，存在堆里，没毛病。
第三种，在方法里的。我们知道在方法被调用时会被加载到栈中进行执行，所以写在方法里的变量存在栈中，也没毛病。


5.reference（对象实例的引用)
我的理解是:一个超链接
一般来说，虚拟机都能从引用中直接或者间接的查找到对象的以下两点 ：
a.在Java堆中的数据存放的起始地址索引。
b.所属数据类型在方法区中的存储类型。


---------------------------------------------
Java对象保存在内存中时，由以下三部分组成：
1，对象头
2，实例数据
3，对齐填充字节（对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能）

java 对象头包括：
1，Mark Word
2，指向类的指针
3，数组长度（只有数组对象才有）

-----------------------------------------------
栈帧内部结构：
1) 局部变量表（Local Variables）本地变量表，主要用于存储方法参数和定义在方法体内的局部变量.存放基本数据类型、对象引用(reference)以及return address类型
2) 操作数栈（Operand Stack）或表达式栈
3) 动态链接（Dynamic Linking）或指向运行时常量池的方法引用
4) 方法返回地址（Return Address）或方法正常退出或异常退出的定义
5) 一些附加信息



局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 “this” 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。
栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程

局部变量表（Local Variable Table） 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量



==================================================================
栈（方法栈）
栈内存用来存放一些基本类型的变量、数组和对象的引用

栈帧（stack frame）
栈帧（出入栈的元素）中存储了方法局部变量表，操作数栈，动态链接，方法返回地址等信息。
局部变量表(Local variables)
操作数栈(operand Stack) ( 或表达式栈)
动态链接(Dynamic Linking) ( 或指向运行时常量池的方法引用)
方法返回地址(Return Address) (或方法正常退 出或者异常退出的定义)
一些附加信息

用于支持虚拟机进行方法调用和方法执行的数据结构
每个方法的调用开始至执行完成的过程都对应一个栈帧在虚拟机栈里面的入栈及出栈过程。
栈帧随着方法调用而创建，随着方法结束而销毁――无论方法正常完成还是异常完成都算作方法结束。


1.局部变量表：存放方法参数及方法内部定义的局部变量。
1.1当一个方法被调用时，会使用局部变量表来完成参数值到参数变量列表的传递过程。如果执行的是对象实例的成员方法（没有被static修饰的方法），那么局部变量表中第0位索引的变量槽默认就是该对象实例的引用，在方法中可以通过关键字this来访问到这个隐含的参数。其余参数则按照参数表顺序排列，参数表分配完毕后，再根据方法体内部定义的局部变量顺序和作用域分配其余的变量槽。为了尽可能节省栈帧所耗的内存空间，局部变量表中的变量槽是可以重用的，当方法体中定义的局部变量超出其作用域时，该局部变量对应的变量槽就可以交给其他变量来重用

1.2在类加载过程中，类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予代码中定义的初始值。因此即使没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值，不会产生歧义。但是局部变量不像类变量有那样的“准备阶段”，如果一个局部变量定义了但没有赋初始值，那它是完全不能使用的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false等这样的默认值规则



基本数据类型  、 引用数据类型
成员变量（在使用前，都经历过默认初始化值) ：类变量（liking的prepare阶段给类变量默认赋值，在initial阶段，给类变量显示赋值及静态代码块赋值）
实例变量（随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值）
局部变量表，定义为一个数组，主要用于存储方法参数（形参）和定义在方法体内的局部变量，最基本的存储单位是Slot（槽）
占用两个Slot的变量也就是double和long，只需要使用前一个索引即可

局部变量：在使用前，必须进行显示赋值，否则编译不通过
当前方法为实例方法（或构造方法），那么JVM会默认创建一个this变量存储在index0处
局部变量表中第0位索引的Slot默认“this”关键字的引用
在编译期间由code属性中的max_locals确定局部变量表的大小；
局部变量表最小单位variable slot(变量槽)；
局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。
reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了
Java语言中明确的(reference类型则可能是32位也可能是64位)64位的数据类型只有long和double两种
Slot可重用，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域,那这个变量对应的Slot就可以交给其他变量使用。

2.操作数栈：
各种字节码指令执行时，会对操作数栈进行出栈和入栈的操作
2.1后进先出，先进先出栈；
2.2栈深度由code属性max_stacks确定；
2.3 32位数据点用1个slot,64位数据(long,double)点用2个slot;
2.4整数加法的字节码指令iadd，在该指令执行前必须保证操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当该指令执行时，会把这两个int值出栈并相加，然后将相加的结果重新入栈
2.5两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多Java虚拟机的实现是，都会进行一些优化：两个不同方法的栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些内存空间，更重要的是在进行方法调用时就可以直接共用一部分数据，不需要进行额外的参数复制和传递

3.动态链接：指向当前方法所属的类的运行时常量池的引用（将符号引用转化为直接引用过程）
查找被引用的类，如果必要的话就加载它；
将符号引用转化为直接引用。	

4.方法返回地址：方法返回地址用于恢复调用当前方法的方法的执行状态
方法返回的过程实际上等同于把当前栈帧出栈，可能执行的操作有：恢复调用者的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整程序计数器的值使其指向方法调用指令后面的一条指令等等


普通调用指令
invokestatic：调用静态方法，解析阶段确定唯一方法版本
invokespecial：调用<init>方法、私有即父类方法，解析阶段确定唯一方法版本
invokevirtual：调用所有虚方法
invokeinterface：调用接口方法
动态调用指令:
invokedynamic：动态解析出所有需要的方法，然后执行，(lamble表达式)，和python一样，变量不需要自己执行，运行时才知道

-XX:+PrintGCDetails -XX:+PrintGCTimeStamps

================================================================================================
一、类加载
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构；
类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
简单的说，类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例，这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。

加载，验证，准备，解析，初始化，使用和卸载 7个阶段
验证，准备，解析三个部分统称为linking 链接

（1）通过一个类的全限定名来获取其定义的二进制字节流
（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

二、类加载时机（主动引用）
1.使用new关键字实例化对象（指令new）；
2.访问某个类或接口的静态变量，或者对该静态变量赋值（被final修饰及已在编译期把结果入常量池的静态字段除外）指令getstatic、putsatic；
3.调用一个类的静态方法（invokestatic指令）
4.包含main方法的类会被初始化
5.反射（Class.forName("com.lyj.load")）
6.初始化一个类的子类（会首先初始化子类的父类）

三、非主动引用（不触发类初始化）
1.通过子类引用父类的静态变量，不会导致子类初始化（对于静态字段只有直接定义这个字段的类才会被初始化）
2.读取常量（final static修饰）不会触发定义类的初始化
3.通过数组定义来引用类，不会触发此类的初始化

四、类加载详细过程
先将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，
一个指向加载自己的classLoader。那么方法区中的字节码内存块，除了记录一个class自己的class对象引用和一个加载自己的ClassLoader引用

五、方法区存放内容：
1.类型信息；
2.字段信息；
3.方法信息；
4.常量池；
5.静态常量；
6.一个到class类的引用;
7.一个到类classloader的引用

六、堆中实例化对象结构
1.对象头（markword【如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等】，klass类型指针即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例），
2.实例数据，
3.对齐填充

JAVA 构造代码块{}
直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数；
构造代码块中的代码也是在构造方法中执行的。在编译时的编译器看来会默认将构造代码块中的代码移动到构造方法中，并且移动到构造方法内容的前面


静态方法：通过类名.方法（）访问
声明为static的方法有以下几条限制： 
1. 它们仅能调用其他的static 方法。
2・ 它们只能访问static数据。
3.它们不能以任何方式引用this 或super。

静态变量：通过类名.变量名 访问
类变量，类的所有实例共享的变量

静态类：
普通类不可申明为静态类；只有一个内部类可以；申明为静态内部类可以直接作为一个普通类使用，而不用实例化一个外部类。

1.初始化代码执行顺序是：父类静态→子类静态→父类普通代码块→子类普通代码块→父类构造方法→子类构造方法
2.静态方法属于类不属于对象；静态方法中只能访问其他静态方法和静态数据，不能访问非静态的。
3.静态不可用this调用。




偏向锁，轻量级锁和重量级锁到底有什么不同了？
这里总结一下，偏向锁下次进入的时候不需要执行CAS命令，只做线程ID的比较即可。
轻量级锁进入和退出同步块都需要执行CAS命令，但是轻量级锁不会阻塞，它使用的是自旋命令来获取锁。
重量级锁不使用自旋，但是会阻塞线程。
========================================================================================
   Java中内存分成两种，一种叫做栈内存，一种叫做堆内存。还有一个方法区，也叫做静态区。
1.栈内存中放哪些东西？
 ①基本类型的变量，例如int a=3中的a；
 ②对象的引用变量，例如Thread t=new Thread();中的t。
      当在代码块中定义一个变量时，Java就在栈中为这个变量分配内存空间；当超过变量的作用域后，Java会自动 释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

2.堆内存中存放哪些东西？
 ① 存放由new创建的对象和数组。
     在堆中存放的内存，由Java虚拟机垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量持有的内容等于数组或者对象在堆内存中的首地址。在栈中的这个特殊的变量，就成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。
 
3.静态区/方法区：
    方法区(method)也叫做静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。
    方法区中包含的都是在整个程序中永远唯一的元素，例如class，static变量。
    全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量放在相邻的另一块区域。
 
堆内存和栈内存，两者的区别？ 
 ①引用变量是普通变量，定义时在栈内存中分配，引用变量在程序运行到作用域外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在的代码块之外，数组和对象本身占用的堆内存也不会被释放。数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉，这个也是Java比较占内存的主要原因。实际上，栈中的引用变量指向堆内存中的变量，这就是Java中的指针。
 
 ②通俗来讲，堆是用来存放对象的，而栈是用来执行程序的。
 ③jvm只有一个堆区(heap)，被所有线程共享；
 每个线程包含一个栈区(stack)，每个栈中的数据都是私有的，其他的栈不能访问，但是同一个栈中变量是共享的；分为3个部分：基本类型变量区，执行环境上下文，操作指令区。
 
 

为什么要有堆和栈？这样设计有什么好处？
 ①Java自动管理堆和栈，程序员不能直接地设置栈和堆。
 ②Java的堆是一个运行时数据区。堆是由JVM的垃圾回收器自动管理的。堆的优势是可以在程序运行时，动态地分配内存
 大小，但是正是由于这个原因，它的存取速度较慢。
 ③栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小和生存期是必须确定的，缺乏灵活性。
     栈有一个很重要的特性，就是存在栈中的数据可以共享。假设我们同时定义：

　　int a = 3;

　　int b = 3;

    编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用时
指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。








CAS的底层实现  https://blog.csdn.net/u013837825/article/details/105776597

Class对象的三种获取方式：
类名.class――不会自动加载
实例化对象.getClass()
Class.forName(包名+类名)――如果类没被加载呢，贼会自动加载

方法区解析：比较经典的文章参考：https://my.oschina.net/chkui/blog/1580757
CPU只关心一堆指令，而JVM中所有的指令都是放置在方法区中的。JVM的首要任务是把这些指令有序的组织起来，按照编程好的逻辑将指令一个一个交给CPU去运行。而CPU都是靠线程来组织指令运算的，所以JVM中每个线程都有一个线程栈，通过他将指令组织起来一个一个的交给CPU去运算――这就是计数器（Counter Register，用以指示当前应该执行什么字节码指令）、线程栈（Stacks，线程的运算模型――先进后出） 和 栈帧（Stacks Frame，方法执行的本地变量） 的概念。所以无论多复杂的设计，方法区可以简单的理解为：有序的将指令集组织起来，并在使用的时候可以通过某些方法找到对应的指令集合。


方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，方法编译出的字节码也是保存在这个区域。
方法区还存放两个引用，一个至类CLASS类的引用，一个到类的classLoader的引用
备注：堆内存中的java.lang.Class实例中对象头的klass类型指针 指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例

方法区中存的就是代码，也就是方法的指令数据（第一步执行什么，第二部执行什么）
Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它有另外一个名字叫Non-Heap（非堆）。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常
JDK7之前java.lang.OutOfMemoryError: PermGenspace

永久代 存储包括类定义、结构、字段、方法（数据及代码）以及常量在内的类相关数据 通过：-XX:PermSize及-XX:MaxPermSize，而JDK8开始，持久代已经被彻底删除了，取代它的是另一个内存区域也被称为元空间

方法区存储的是每个class的信息:
1.类加载器引用(classLoader)
2.运行时常量池
所有常量、字段引用、方法引用、属性
3.字段数据
每个方法的名字、类型(如类的全路径名、类型或接口) 、修饰符（如public、abstract、final）、属性
4.方法数据
每个方法的名字、返回类型、参数类型(按顺序)、修饰符、属性
5.方法代码
每个方法的字节码、操作数栈大小、局部变量大小、局部变量表、异常表和每个异常处理的开始位置、结 束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

特点
    1.方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待。

    2.方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。

    3.方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集


1.方法存放在方法区的，并且方法区中是方法的静态表现。
2.栈区中的每个开辟的栈帧是方法的一次执行过程，方法开始执行时产生，执行完销毁，他是方法的动态表现，并且方法被调用几次，就会出现几次。

栈区（虚拟机栈）：主要是存储局部变量表（当然也还有其他信息）。

------------------------------------------------------------------------------------------------------
0: new           #2                  // class example/classLifecicle/SimpleClass
3: dup
4: invokespecial #3                  // Method "<init>":()V
7: astore_1
8: return

总结：
CPU机器指令：
根据指令后面 常量池index 识别到执行的是哪个类或方法；
如invokespecial #3  执行的是class example/classLifecicle/SimpleClass Method "<init>":()V 构造方法【根据入参，方法名，返回类型识别方法表获取其对应的方法体（code指令集） 】

===============================================================================================================
jvm内存分类 堆内存(heap) 和 非堆内存（永久代permGen）
堆内存 分为 年青代（Eden生成区，Survivor(幸存区，FromSpace ToSpace) Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1），老年代
堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。
非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。
在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存

分代概念：
新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。
老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。
Minor GC ： 清理年轻代
Major GC ： 清理老年代
Full GC ： 清理整个堆空间，包括年轻代和永久代
所有GC都会停止应用所有线程。

分代原因：将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率

OOM（Out of Memory）异常常见有以下几个原因：
1）老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace
2）永久代内存不足：java.lang.OutOfMemoryError:PermGenspace




类的加载（懒加载，仅加载一次）
类加载过程：加载，链接（验证，准备（为类变量static分配内存并赋预初值,父类未初始化，优先初始化父类），解析（符号引用转化直接引用）），初始化，使用，卸载
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在java堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class 对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。


加载：将类的class文件读入内存，并为之在堆中创建一个与之对应的java.lang.Class对象，作为方法区中数据的访问入口(即引用地址),此过程由类加载器完成。
类缓存：一旦类被加载至类加载器中，它将维持加载（缓存）一段时间，不过JVM回收机制可以回收这些CLASS

验证：确保加载类信息符事JVM规范；
准备：为类变量（static）分配内存，并设置类变量默认初始值，这些内存都将在方法区内存进行分配；
解析：将虚机常量池中的符号引用（常量名）替换为直接引用（地址引用）过程。

初始化：执行类构造器<clinit>()方法过程（初始化方法）
1.类构造器<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作及静态代码块中的语句合并产生的（备注：类构造器是构造类信息的，不是构造该类对象的构造器）。
2.初始化时，发现父类未初始化，会触发父类初始化
3.虚机保证一个类的<clinit>方法在多线程环境中被正确加锁和同步。



备注：
成员变量（在使用前，都经历过默认初始化值) ：类变量（liking的prepare阶段给类变量默认赋值，在initial阶段，给类变量显示赋值及静态代码块赋值）
实例变量（随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值）
局部变量：在使用前，必须进行显示赋值，否则编译不通过

为什么会有自定义类加载器？
一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。
另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。

----------------------------------------------------------------------------------------------
public class BarClass {  
    private static Properties propTable;  
    static {  
        try {  
            propTable.load(new FileInputStream("/data/user.prop"));  
        } catch (Exception e) {  
            propTable.put("user", System.getProperty("user"));  
            propTable.put("password", System.getProperty("password"));  
        }  
    }  
}  

1.JVM 保证使用同一个 ClassLoader 加载的类中的 static initialization block 只被执行一次，因而它是线程安全的。
2.static 先于 non-static, non-static 先于 constructor。这里的 static 统指 static field 和 static initialization block 两种初始化方式；
3.static 初始化代码按照在源代码中定义的顺序从上往下以此执行；
4.存在继承关系时，优先执行基类中的初始化语句