securecrt ftp文件方式：
ALT+P
rz 打出上传文件
命令"sz 文件名",即可利用Zmodem将文件下载到本地某目录下

---------------------------------------------
int char可相互转化
indexOf(58) 等价 indexOf(':') //58 ascii码值对应“:”
---------------------------------------------


每当 new 一个 Promise 实例的时候，就会 立即执行这个 异步操作中的代码，也就是说，new 的时候，
除了能够得到一个 Promise 实例之外，还会立即调用 我们为 Promise构造函数 传递的那个 function , 执行这个 function 中的 异步操作代码；




securecrt 按下ALT+P就开启新的会话 进行ftp操作。

　　输入：help命令，显示该FTP提供所有的命令

　　pwd:  查询linux主机所在目录（也就是远程主机目录）

　　lpwd: 查询本地目录（一般指windows上传文件的目录：我们可以通过查看"选项"下拉框中的"会话选项",我们知道本地上传目录为：D:/我的文档）

　　ls:   查询连接到当前linux主机所在目录有哪些文件

　　lls:  查询当前本地上传目录有哪些文件

　　lcd:  改变本地上传目录的路径

　　cd:   改变远程上传目录

　　get:  将远程目录中文件下载到本地目录

　　put:  将本地目录中文件上传到远程主机（linux）

　　quit: 断开FTP连接



输出内容至前端页面下载方式：
@RequestMapping(value = "/getPostMan")
public void exportData2PostManJson(HttpServletResponse response){
		JSONObject jsonObject = new JSONObject();
    String uuid = getUUid();
    jsonObject.put("id",uuid);
    jsonObject.put("name","TEST-"+uuid);
    jsonObject.put("description","自动化测试");
    
    response.setHeader("Content-Disposition", "attachment; filename="xx.json");
    Integer contentLength = jsonObject.toJSONString().getBytes().length;
    response.setHeader("content-length", contentLength + "");
    try {
        response.getOutputStream().write(jsonObject.toJSONString().getBytes());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
    

  
springboot中前端ajax传值与后台的接收

第一种方式，不使用任何注解。
前端 
   var data = "username="+vm.username+"&password="+vm.password+"&captcha="+vm.captcha;
            $.ajax({
                type: "POST",
                url: "sys/login",
                data: data,
                dataType: "json",

后台接收
    public R login( String username, String password, String captcha)

 2.使用注解@PathVariable

 前端
     $.get(baseURL + "noticeinfo/info/"+noticeid

后台
    public R info(@PathVariable("noticeid") Integer noticeid) 

  3.使用注解@RequestParam

    前端
     url : baseURL + "noticeinfo/saveimg?noticeid=" + param 

   后台
    public R info(@RequestParam(noticeId) String noticeId)

4. 使用注解@RequestBody

前端
   $.ajax({
                type: "POST",
                url: baseURL + url,
                contentType: "application/json",
                data : JSON.stringify(vm.noticeInfo)

后台 ，有两种方式
   public R update(@RequestBody NoticeInfoEntity noticeInfo) 

   可以直接使用一个map来接收。

   public R update(@RequestBody Map<String, Object> params) 
   

XMLHttpRequest
  try {
                var data = {};
                data['url'] = url;
                data['requestParams'] = text;
                data['response'] = content;
                data['reqTime'] = formatDateToLong(args[0].startedDateTime);
                var xhr = new XMLHttpRequest();
                xhr.withCredentials = true;
                xhr.onerror = function (e) {
                    log("连接异常:", e.stack || e.toString);
                };

                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            log("url:",url,"请求数据成功发送至：" + collectServersIp, xhr.responseText)
                        } else {
                            // 错误处理
                            log("请求数据至收集服务器异常:", xhr.statusText, xhr.responseText);
                        }
                    }
                }

                xhr.open("post", collectServersIp, false);
                xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xhr.send(JSON.stringify(data));
                //log("请求数据推送状态：",xhr.status,"state:",xhr.state);


            } catch (errinfo) {
                log("请求数据发送服务端异常：", errinfo.stack || errinfo.toString());
            }


java程序启动参数-D含义详解
-D<name>=<value>  ：  set a system property  设置系统属性。
java代码中通过System.getProperty("key")获取对应设置的值
Standard System Properties


===================================================================
springboot 使用spring.profiles.active 区分不同环境下配置文件
application.properties文件中增加如下配置
spring.profiles.active=test

则使用test环境，具体resource文件夹下存放文件如下
application.properties
application-test.properties
application-prd.properties

JAVA启动时指定启用配置文件方式：
java -jar app.jar --spring.profiles.active=dev --server.port=8060  //指定端口
=====================================================================

在pom.xml中使用distributionManagement将项目打包上传到nexus私服


1、pom.xml文件添加distributionManagement节点
<!-- 使用分发管理将本项目打成jar包，直接上传到指定服务器 -->
  <distributionManagement>
    <!--正式版本-->
    <repository>
        <!-- nexus服务器中用户名：在settings.xml中<server>的id-->
        <id>yang</id>
        <!-- 这个名称自己定义 -->
        <name>Release repository</name>
        <url>http://192.168.1.105:8081/repository/yang/</url>
    </repository>
    <!--快照
    <snapshotRepository>
        <id>nexus-snapshots</id>
        <name>Snapshots repository</name>
        <url>http://192.168.1.105/repository/yang/</url>
    </snapshotRepository>-->
  </distributionManagement>

< repository >节点下的< id >对应setting.xml文件中的server的id

    <!--maven连接nexus需要验证用户名和密码-->
    <server>
      <id>yang</id>
       <username>admin</username>
       <password>admin123</password>
     </server>

上传正式版本，pom.xml文件version中不能有SNAPSHOT，快照版本才有

  <groupId>com.yang</groupId>
  <artifactId>shade-plugin</artifactId>
  <version>0.0.1</version>
  <!--  <version>0.0.1-SNAPSHOT</version> -->

------------------------------------------------------------------------
内部函数内部使用匿名函数时，this将会指向到全局window对象
var声明的全局变量属于全局对象的属性，即意味着我们可以通过window.变量名的方式访问到。

JS中的this 
https://www.cnblogs.com/echolun/p/11969938.html
https://www.cnblogs.com/echolun/p/11962610.html

1.this的值通常是由当前函数的执行环境所决定；
2.在全局作用域，this指向全局对象 (window对象)；
3.当使用new关键字声明，this指向新建对象；
4.我们可以使用call(), bind(), apply()来设置this；
5.箭头函数不会绑定this，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁


--------------------------------------------------------
js 函数申明的两种方式
1.函数表达式
var fn = function(){}
2.直接申明
function fn(){
}
第一种方式，函数只能在声明之后调用。因为这种方式声明的函数，是在函数运行的阶段才赋值给变量 f 的；
第二种方式，函数可以在声明函数的作用域内任一地方调用。因为这种方式，是在函数解析阶段赋值给标识符 f .
值得注意的是，当同时使用这两种方式声明同一个函数名，最终执行的是函数表达式声明的函数。


js 反撇号（`）模板字符串加合点位符${} 使用 `${user.name}`


var
1.可以不初始化，值为undefined
2.可以重复声明
3.声明的全局变量为全局对象的属性
4.作用域：函数作用域
5.存在变量提升现象

let 
1.可以不初始化，值为undefined
2.不可重复声明
3.声明的全局变量不是全局对象的属性
3.作用域：块级作用域
4.无变量提升现象

const
1.必须初始化
2.不可重复声明
3.作用域：块级作用域
4.不存在变量提升现象
5.声明的基本数据类型值为常量，之后值不可修改，声明的数组等对象可以进行修改

获取对象属性的方式
1、对象.属性名称  如 obj.age
2、对象[属性名称] 如 obj[age]
3、动态获取属性名称 obj[`${type}`]

优化if-else
1.swith() case方式
2.||或&& 短路求值，三元运算
3.根据类型名放function至map中，调用时通过map.get(type)方式获取执行方法function;
4.根据类型生成object 调用时通过obj[`${type}`]()方式 动态调用执行
具体如下：

let x = x ||"test"  //设置默认值

--------------------------------------------

function del(){
    console.log("del")
}

_Type = new Map();
_Type.set("add",function(){console.log("add")});
_Type.set("del",function(){console.log("del")});
function process(type='del'){
    _Type.get(`${type}`)();
}

process();

---------------------------------------
const rules = {
    "add":function(){
        console.log("add");
    },
    "del":function(){
        console.log("del");
    }
}

let funT = function(x){
    rules[`${x}`]();
}

funT("del");
-------------------------------------------
js 闭包
1. 可以在函数的外部访问到函数内部的局部变量。 
2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。
========================================================================================
js中的匿名函数
function fn(){
  console.log('test');
}
去掉普通函数的名字即匿名函数如下
function(){
 console.log('test');
}

匿名函数的执行,外层用()包裹后跟()如下:
(function(){
	console.log('test');
})();

执行需要入参的匿名函数
(function(str){
  console.log('hello'+str);
})('fhj');

备注：
0.(funtion(){})()； 或者(function(){}())立即执行函数；相当于先申明一个函数，声明完后直接调用；
1.由于()优先级高所有声明完函数后立即执行，另外类似的一元操作符!+-可以起到类似的作用如下：!function(){console.log('test')}()
2.通过匿名函数可以实现闭包，执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存，大大降低命名冲突的问题。

JavaScript中的闭包永远都存储在内存中，除非关闭浏览器