java 枚举类
java 单例

子类重写父类方法时，方法的访问权限不可小于原访问权限。

----------------------------
java 构造方法总结：
构造方法: 方法名同类型([参数列表]){}
1.方法名与类名相同，方法名前没有返回值类型申明（void 也不可以），方法中不能有return返回一个值；
2.构造方法同普通方法可以重载（但构造方法是不被继承的），以参数的个数，类型，或排列顺序区分；
3.构造函数不能被继承，也不能直接被调用；构造方法可以通过this()调用其他构造函数，通过super()调用父类构造函数，但这两个都方法都必须是调用方法的第一句；
4.创建子类对象时，首先执行父类构造方法，然后再执行子类构造方法；多级继承情况下，从继承最上层开始依次执行各类的构造方法；
如果子类构造方法中没有super语句显示调用父类的构造方法，创建子类对象时会自动调用父类默认的构造方法，若父类没有默认构造方法，则编译出错。
5.每个类中至少有一个构造函数，如果没有系统会创建一个默认的无参构造函数，若已定义构造方法后则不会再自动创建默认的无参构造函数了；
4.构造方法不能由编程人员调用，而要系统调用
5.构造方法不能被static、final、synchronized、abstract和native修饰
6 构造方法被调用的几种方式：当前类的其他构造方法通过this语句调用它；当前类的子类的构造方法通过super语句调用它；在程序中通过new语句调用它。
7构造方法可以处于public、protected、private和默认四种访问级别之一。
 当构造方法为private级别时，意味着只能在当前类访问它，不能被继承，不能被其他程序用new创建实例对象。
 abstract修饰的类，不允许被实例化，这点和private修饰构造方法相同，但abstract修饰的类可以被继承，拥有子类，可以创建子类的实例；
 final类禁止被继承，这点和private修饰构造方法相同，但是final类可以用new创建实例对象。
 
且必须作为构造方法的第一条语句，成员方法中不可调用构造方法。
父类的构造方法不能被子类继承，但是，在子类的构造方法中可以通过super语句调用父类的构造方法。使用super语句应该注意：在子类的构造方法中使用super语句，它必须作为第一条语句。
在创建子类的对象时，java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法，在多级继承的情况下，将从继承树的最上层得父类开始，依次执行各个类的构造方法，这可以保证子类对象从所有直接或间接父类中继承的实例变量都被正确的初始化。
如果子类的构造方法中没有用super语句显示调用父类的构造方法，那么通过这个构造方法创建子类对象时，java虚拟机会自动先调用父类的默认构造方法，而此时若父类没有默认构造方法时，就是编译出错





java 修饰符
访问修饰符
default(friendly) 默认访问模式，默认修饰符（即不加任何访问修饰符），只允许在同一包内访问；使用对象：类，接口，变量，方法
private 私有访问修饰符。被其修饰的内部类，属性，方法只可在本类中访问，其子类不可访问，更不允许跨包访问。使用对象：变量，方法。注意：外部类不可修饰 （访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据）
protected 保护型访问修饰符，被其修饰的内部类，属性，方法仅能被其本身类或其子类访问，即使子类不在同一包中。 使用对象：变量，方法，注意：不能修饰外部内，接口及接口成员方法及成员变量
public 公共访问修饰符，可以被任何对象访问，被其修饰的类，方法，属性不仅可以跨类访问而且允许跨包访问。使用对象：类，接口，变量，方法 （接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public）

非访问修饰符
static
final

访问修饰符的继承
1.父类声明private方法 不能被继承；
2.父类申明public方法，子类方法必须也只能是public；
3.父类声明protected方法，子类方法只能声明为protected或public,不能为private



接口，比抽象类还要抽象的类:

接口中的方法会被隐式的指定为  public abstract （只能是 public abstract，其他修饰符都会报错）。
接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）
java接口里的成员变量只能是public 的，static 的，final的；并且必须赋初值，否则通不过编译。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
注：
接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字。
接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字。
接口中的方法都是公有的( public ) ！！！ 不是 default

public: 使接口的实现类可以使用这个常量
static：接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。
            static修饰就表示它属于类的，随的类的加载而存在的，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了。
            如果是非static的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为static。
final：
            接口中不可以定义变量即定义的变量前都要加上final修饰，使之成为常量(没有final修饰的是变量，加上final修饰就会变成常量)。所以接口的属性默认是public static final 常量，且必须赋初值。
            （  final修饰就是保证接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意去修改的话，接口建立这个常量就没有意义了。）
 
接口中方法的修饰符：public abstract（默认不写）
abstract：
接口仅仅描述系统能做什么，但是不指名如何去做，所以接口中的方法都是抽象（abstract）方法。


Xmind
-------------------
股票量化：https://blog.csdn.net/wuu1299/article/details/78965555?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase
https://blog.csdn.net/weixin_44434573/article/details/86491664?utm_medium=distribute.pc_relevant_download.none-task-blog-BlogCommendFromBaidu-6.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-BlogCommendFromBaidu-6.nonecas

https://github.com/daveqin/stock/blob/master/README.md

java 字节码查看IDEA插件工具：jclasslib

ngModel指令需要引入 import {FromsModule} '@angular/froms'
当在表单中使用[(ngModel)]时，必须要定义name属性。

providers - 一个数组，包含组件所依赖的服务所需要的依赖注入提供者，可用于当前Component及其子视图；


securecrt ftp文件方式：
ALT+P
rz 打出上传文件
命令"sz 文件名",即可利用Zmodem将文件下载到本地某目录下

angular8
ctrl+shift+j == F12

---------------------------------------------
int char可相互转化
indexOf(58) 等价 indexOf(':') //58 ascii码值对应“:”
---------------------------------------------


每当 new 一个 Promise 实例的时候，就会 立即执行这个 异步操作中的代码，也就是说，new 的时候，
除了能够得到一个 Promise 实例之外，还会立即调用 我们为 Promise构造函数 传递的那个 function , 执行这个 function 中的 异步操作代码；




securecrt 按下ALT+P就开启新的会话 进行ftp操作。

　　输入：help命令，显示该FTP提供所有的命令

　　pwd:  查询linux主机所在目录（也就是远程主机目录）

　　lpwd: 查询本地目录（一般指windows上传文件的目录：我们可以通过查看"选项"下拉框中的"会话选项",我们知道本地上传目录为：D:/我的文档）

　　ls:   查询连接到当前linux主机所在目录有哪些文件

　　lls:  查询当前本地上传目录有哪些文件

　　lcd:  改变本地上传目录的路径

　　cd:   改变远程上传目录

　　get:  将远程目录中文件下载到本地目录

　　put:  将本地目录中文件上传到远程主机（linux）

　　quit: 断开FTP连接



输出内容至前端页面下载方式：
@RequestMapping(value = "/getPostMan")
public void exportData2PostManJson(HttpServletResponse response){
		JSONObject jsonObject = new JSONObject();
    String uuid = getUUid();
    jsonObject.put("id",uuid);
    jsonObject.put("name","TEST-"+uuid);
    jsonObject.put("description","自动化测试");
    
    response.setHeader("Content-Disposition", "attachment; filename="xx.json");
    Integer contentLength = jsonObject.toJSONString().getBytes().length;
    response.setHeader("content-length", contentLength + "");
    try {
        response.getOutputStream().write(jsonObject.toJSONString().getBytes());
    } catch (IOException e) {
        e.printStackTrace();
    }
}
    

  
springboot中前端ajax传值与后台的接收

第一种方式，不使用任何注解。
前端 
   var data = "username="+vm.username+"&password="+vm.password+"&captcha="+vm.captcha;
            $.ajax({
                type: "POST",
                url: "sys/login",
                data: data,
                dataType: "json",

后台接收
    public R login( String username, String password, String captcha)

 2.使用注解@PathVariable

 前端
     $.get(baseURL + "noticeinfo/info/"+noticeid

后台
    public R info(@PathVariable("noticeid") Integer noticeid) 

  3.使用注解@RequestParam

    前端
     url : baseURL + "noticeinfo/saveimg?noticeid=" + param 

   后台
    public R info(@RequestParam(noticeId) String noticeId)

4. 使用注解@RequestBody

前端
   $.ajax({
                type: "POST",
                url: baseURL + url,
                contentType: "application/json",
                data : JSON.stringify(vm.noticeInfo)

后台 ，有两种方式
   public R update(@RequestBody NoticeInfoEntity noticeInfo) 

   可以直接使用一个map来接收。

   public R update(@RequestBody Map<String, Object> params) 
   

XMLHttpRequest
  try {
                var data = {};
                data['url'] = url;
                data['requestParams'] = text;
                data['response'] = content;
                data['reqTime'] = formatDateToLong(args[0].startedDateTime);
                var xhr = new XMLHttpRequest();
                xhr.withCredentials = true;
                xhr.onerror = function (e) {
                    log("连接异常:", e.stack || e.toString);
                };

                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            log("url:",url,"请求数据成功发送至：" + collectServersIp, xhr.responseText)
                        } else {
                            // 错误处理
                            log("请求数据至收集服务器异常:", xhr.statusText, xhr.responseText);
                        }
                    }
                }

                xhr.open("post", collectServersIp, false);
                xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xhr.send(JSON.stringify(data));
                //log("请求数据推送状态：",xhr.status,"state:",xhr.state);


            } catch (errinfo) {
                log("请求数据发送服务端异常：", errinfo.stack || errinfo.toString());
            }


java程序启动参数-D含义详解
-D<name>=<value>  ：  set a system property  设置系统属性。
java代码中通过System.getProperty("key")获取对应设置的值
Standard System Properties


===================================================================
springboot 使用spring.profiles.active 区分不同环境下配置文件
application.properties文件中增加如下配置
spring.profiles.active=test

则使用test环境，具体resource文件夹下存放文件如下
application.properties
application-test.properties
application-prd.properties
备配置文件格式:application-{profile}.properties 或 application-{profile}.yml


JAVA启动时指定启用配置文件方式：
java -jar app.jar --spring.profiles.active=dev --server.port=8060  //指定端口
=====================================================================

在pom.xml中使用distributionManagement将项目打包上传到nexus私服


1、pom.xml文件添加distributionManagement节点
<!-- 使用分发管理将本项目打成jar包，直接上传到指定服务器 -->
  <distributionManagement>
    <!--正式版本-->
    <repository>
        <!-- nexus服务器中用户名：在settings.xml中<server>的id-->
        <id>yang</id>
        <!-- 这个名称自己定义 -->
        <name>Release repository</name>
        <url>http://192.168.1.105:8081/repository/yang/</url>
    </repository>
    <!--快照
    <snapshotRepository>
        <id>nexus-snapshots</id>
        <name>Snapshots repository</name>
        <url>http://192.168.1.105/repository/yang/</url>
    </snapshotRepository>-->
  </distributionManagement>

< repository >节点下的< id >对应setting.xml文件中的server的id

    <!--maven连接nexus需要验证用户名和密码-->
    <server>
      <id>yang</id>
       <username>admin</username>
       <password>admin123</password>
     </server>

上传正式版本，pom.xml文件version中不能有SNAPSHOT，快照版本才有

  <groupId>com.yang</groupId>
  <artifactId>shade-plugin</artifactId>
  <version>0.0.1</version>
  <!--  <version>0.0.1-SNAPSHOT</version> -->

------------------------------------------------------------------------
内部函数内部使用匿名函数时，this将会指向到全局window对象
var声明的全局变量属于全局对象的属性，即意味着我们可以通过window.变量名的方式访问到。

JS中的this 
https://www.cnblogs.com/echolun/p/11969938.html
https://www.cnblogs.com/echolun/p/11962610.html

1.this的值通常是由当前函数的执行环境所决定；
2.在全局作用域，this指向全局对象 (window对象)；
3.当使用new关键字声明，this指向新建对象；
4.我们可以使用call(), bind(), apply()来设置this；
5.箭头函数不会绑定this，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁

console.dir()查看一个变量、函数、对象内部的属性和值
--------------------------------------------------------------
js中call bind apply
call apply会立即执行，bind会返回一个新方法；
bind、call、apply指明Function函数的this指向（指定的类和Function函数强力的粘贴在一起）

call()和apply()的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用
**call同apply类似，传参时不一样
**bind生成返回新的函数 将

apply：方法能劫持另外一个对象的方法，继承另外一个对象的属性。


function fn(n1,n2){
    return this.name+(n1+n2);
}

var params={
    name:"test by fanghj:"
}

console.log(fn.call(params,11,22));
console.log(fn.apply(params,[10,20]));

console.log(fn.bind(params)(10,20));


bind是返回新的函数，以便稍后调用
它们的第一个参数都是用来更改调用方法中this的指向

bind()方法创建一个新的函数（称为绑定函数）, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。
语法：
fun.bind(thisArg[, arg1[, arg2[, …]]])


1.改变函数运行上下文  
2.改变函数体内部this的指向
3.实现继承 可以让CALL中的对象调用当前对象拥有的function
fn.method.call(b) 即让b拥有fn的method方法并执行如下：
fn.call(x,a,b)   //传参散列化
fn.apply(x,[a,b]) //传参数组
fn.bind(x)(a,b)  //将fn函数bind至对象

var shoppingCart = (function () {
    var _calculatePrice = function () {
        return this.price * this.amount;
    };
    return {
        calculatePrice: _calculatePrice
    }
})();
var goods = {
    name: "hammer",
    price: 199,
    amount: 2
};
shoppingCart.calculatePrice.call(goods);

============================================================
与bind类似的方法还有call和apply，其中的第一个参数都可以理解为  "将自己伪装成参数的成员函数"  其中call和apply 都会立即执行，bind会返回一个新方法。 

如：

function fun(x,y){}

var thisArg = {};

var fun2 = fun.bind(thisArg)

fun2(1,2)

效果等同于

var thisArg = {fun2:function(x,y){}};

thisArg.fun2(1,2);


---------------------------------------------------------


--------------------------------------------------------
js 函数申明的两种方式
1.函数表达式 //不会进行函数提升，需要先申明再调用。使用先于申明会报错
var fn = function(){}  
2.直接申明 //导致函数提升，所有function关键字都会被解释器优先编译，不管是声明在什么位置，都可以调用它，但是它本身不会被执行，定义只是让解释器知道其存在，只有在被调用的时候才会执行
function fn(){
}
第一种方式，函数只能在声明之后调用。因为这种方式声明的函数，是在函数运行的阶段才赋值给变量 f 的；
第二种方式，函数可以在声明函数的作用域内任一地方调用。因为这种方式，是在函数解析阶段赋值给标识符 f .
值得注意的是，当同时使用这两种方式声明同一个函数名，最终执行的是函数表达式声明的函数。


js 反撇号（`）模板字符串加合点位符${} 使用 `${user.name}`


var
1.可以不初始化，值为undefined
2.可以重复声明
3.声明的全局变量为全局对象的属性
4.作用域：函数作用域
5.存在变量提升现象

let 
1.可以不初始化，值为undefined
2.不可重复声明
3.声明的全局变量不是全局对象的属性
3.作用域：块级作用域
4.无变量提升现象

const
1.必须初始化
2.不可重复声明
3.作用域：块级作用域
4.不存在变量提升现象
5.声明的基本数据类型值为常量，之后值不可修改，声明的数组等对象可以进行修改

获取对象属性的方式
1、对象.属性名称  如 obj.age
2、对象[属性名称] 如 obj[age]
3、动态获取属性名称 obj[`${type}`]

优化if-else
1.swith() case方式
2.||或&& 短路求值，三元运算
3.根据类型名放function至map中，调用时通过map.get(type)方式获取执行方法function;
4.根据类型生成object 调用时通过obj[`${type}`]()方式 动态调用执行
具体如下：

let x = x ||"test"  //设置默认值

--------------------------------------------

function del(){
    console.log("del")
}

_Type = new Map();
_Type.set("add",function(){console.log("add")});
_Type.set("del",function(){console.log("del")});
function process(type='del'){
    _Type.get(`${type}`)();
}

process();

---------------------------------------
const rules = {
    "add":function(){
        console.log("add");
    },
    "del":function(){
        console.log("del");
    }
}

let funT = function(x){
    rules[`${x}`]();
}

funT("del");
-------------------------------------------
js 闭包
1. 可以在函数的外部访问到函数内部的局部变量。 
2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。
闭包在JavaScript高级程序设计（第3版）中是这样描述：闭包是指有权访问另一个函数作用域中的变量的函数。
========================================================================================
js中的匿名函数
function fn(){
  console.log('test');
}
去掉普通函数的名字即匿名函数如下
function(){
 console.log('test');
}

匿名函数的执行,外层用()包裹后跟()如下:
(function(){
	console.log('test');
})();

执行需要入参的匿名函数
(function(str){
  console.log('hello'+str);
})('fhj');

备注：
0.(funtion(){})()； 或者(function(){}())立即执行函数；相当于先申明一个函数，声明完后直接调用；
1.由于()优先级高所有声明完函数后立即执行，另外类似的一元操作符!+-可以起到类似的作用如下：!function(){console.log('test')}()
2.通过匿名函数可以实现闭包，执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存，大大降低命名冲突的问题。

JavaScript中的闭包永远都存储在内存中，除非关闭浏览器

JS闭包closure (倒闭，关闭，停业)
1.闭包：A函数嵌套B函数，B函数使用了A函数的内部变量，且A函数返回B函数，这就是闭包(闭包指代的就是内部函数 insider，而非外部函数outer所包含的范围)

2.所谓闭包其实就是一个自带了执行环境（由外层函数提供，即便外层函数销毁依旧可以访问）的特殊函数

3.百度百科：
闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。

JavaScript中的作用域是指变量与函数的作用范围

--------------------------------------------------------------------------------------------------------------------------------------
立即执行函数的作用是：1.创建一个独立的作用域，这个作用域里面的变量，外面访问不到，这样就可以避免变量污染。2.闭包和私有数据
立即执行函数的写法
(function(){}())
!function(){}()
(function(){})()
function 关键字可以进行函数提升，可以任何地方使用，不必先申明再使用；
如果把函数申明用()或+ - !等修饰则变成函数表达式，且后面加()后即可立即执行；

---------------------------------------------------------------------------------------------------------------------------------------------
全站页面置灰方法CSS
html{
filter: grayscale(100);
}
-------------------------------------------------------------
js中this的绑定 https://www.cnblogs.com/echolun/p/11962610.html
1.默认绑定 函数调用无任何调用前缀对象(xx.fun())，在非严格模式下(在严格模式环境中，默认绑定的this指向undefined)，默认绑定this指定全局对象windows
2.隐式绑定 函数调用时前面存在调用它的对象，那么this就会隐式绑定到这个对象上
  如果函数调用前存在多个对象，this指向距离调用自己最近的对象；
  函数作为参数传递或将函数赋值给变量（隐式绑定丢失）实际上都是调用方都改变成被赋值的对象了如下 ：

//函数赋值给变量
var name ="bb";
function fn(){
  let name ="aa";
  console.log(this.name);
}
var fnA = fn; //将fn()赋值给fnA,调用者是fnA,则this为默认绑定指向的为windows 则结果为bb
fnA();
----------------------
// 函数作参数传递
var name = "bb"
var obj={
    name:'objname',
    fun:function(){
    		console.log(this.name);
    }
}

function fnC(params){
	params();
}
fnC(obj.fun); //将obj.fun函数传给funC来执行，执行者为funC,所以结果应当为 bb;


3.显式绑定。通过call apply及bind方法改变this的行为（函数能主动选择自己的上下文）备注：无法改变箭头函数上下文
注意，如果在使用call之类的方法改变this指向时，指向参数提供的是null或者undefined，那么 this 将指向全局对象
fn.call(obj);
fn.apply(obj);
fn.bind(obj)();

fn.call(null);
fn.call(undefined);
fn.apply();

js API内置显式绑定如
var obj={
	name:"test"
}
[1,2,3].forEach(function(){console.log(this.name)},obj);

4.new绑定，this指向new创建的对象
5.this绑定优化级
 显式绑定 > 隐式绑定 > 默认绑定
 new绑定 > 隐式绑定 > 默认绑定
6.箭头函数的this：箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁
  


============================================================
JS作用域链与原型链的区别：
当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象window，如果window都没有这个变量则报错。
当在对象上访问某属性时，首选i会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是null，如果全程都没找到则返一个undefined，而不是报错。
--------------------------------------------
var 与 let区别
1.var属于ES5范畴,let属于ES6
2.var有预处理机制，let没有。（预处理机制也就是常说的声明提前）　
  备注：声明提前：不管变量被声明在函数什么位置，所有变量声明都会被提升至函数顶部（变量声明指 var a; 即声明还未赋值
   即使在函数内部，声明变量时一定要加上var，不要只写 a = 1; 否则变量a会自动升为全局变量
3.作用域的不同，var是全局作用域，let是块级作用域 (let定义的变量只在{}里才能访问到)
　<script>
        if(true) {
            var let = 1;
        }
        console.log(a); //报错
    </script>
------------------------------------------------------------------------
call、apply与bind有什么区别？
1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，
	这也是为什么上方例子中bind后还加了一对括号 ()的原因。
2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。
3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，
	因为apply在执行时还要多一步解析数组。
	
apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.
=========================================================
js 模板
function fn(name){
	return `my name is :${name}`;
}

============================================================
js 原型链
Promise
eval

-----------------------------------------------------
javascript中的this指向问题：https://www.cnblogs.com/isaboy/archive/2015/10/29/javascript_this.html
函数是否是new进行调用 this 指向创建的对象
             是否使用.调用，是的话，指定.前面的对象，否则指向全局window
             
Arrow Function 词法作用域，没有this 所谓的词法作用域就是一个变量的作用在定义的时候就已经被定义好，当在本作用域中找不到变量，就会一直向父作用域中查找，直到找到为止。

JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因
“JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，
构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，
首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，
则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）
创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。
最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，
函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。”

-----------------------------------------------------------------------------------------------
js new 过程 https://www.cnblogs.com/echolun/p/10903290.html
在《JavaScript模式》这本书中，new的过程说的比较直白，当我们new一个构造器，主要有三步：
1 创建一个空对象，将它的引用赋给 this，继承函数的原型。
2 通过 this 将属性和方法添加至这个对象
3 最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象）

-------------------------------------------------------------------------------------------------
JS对象创建方法：
1.直接量创建（推荐方式）
let obj={name:'',age:12};
obj.method=function(){};
obj.name="";

let obj1={
	name:"xxx",
	method:function(){}
}

2.通过构造函数创建对象
let obj = new Object();
obj.name=""
obj.method=function(){}

3.自定义构造函数创建对象 //建议将所有实例都需要用到的属性添加在prototype上，因为这样在每次new时，不用每次新开内存时都创建一次
//第一，加在原型链上，new实例时不需要反复创建属性造成内存浪费，第二，简化构造函数的属性能减轻对不需要这些属性的实例的困扰，这也是原型链继承的好处
var Person = function(){
  // var this = {}; 创建一个空对象，将它的引用赋给this，继承函数的原型 准确来说是// var this = Object.create(Person.prototype);
	this.name = "xx";
	this.sayName=function(){  //new 一次sayName()方法会反复的被添加到this中，且每次sayName()方法都会在内存中新开内存
		console.log(this.name)
	}
	//return this; 这里隐性返回的其实就是上面创建的空对象，这个空对象被赋予了name属性和一个sayName方法
}
Person.prototype.sayname=function(){}  //解决上述内存占用问题，将方法添加至Person原型上

var p = new Person();
p.sayName();

4.利用构造函数模式实现多继承
function Cat () {
  this.legs = 4;
  this.say = function () {
    console.log('喵~')
  }
};
function Bird() {
  this.wings = 2;
  this.fly = true;
}
function CatWings() {
  Cat.apply(this);
  Bird.apply(this);
};
let miao = new CatWings();
console.dir(miao);

--------------------------------------------------
/**
 * 控制重复执行提交
 * @param {*} fn 需要执行方法
 * @param {*} delay 多久内执行有效
 */
function debounce(fn,delay){
    var timeout = null;
    var startDate = new Date();
    return function(){
        var endDate = new Date();
        clearTimeout(timeout);
        if(endDate-startDate>=delay){
           fn();
        }else{
            timeout = setTimeout(function(){
                fn();
            },delay)
        }
        startDate = endDate;

    }
}

var btn = document.getElementById("btn");
btn.addEventListener("click",debounce(function(){
    $.ajax({
        url:"",
        success:function(res){
            console.log(res)
        }
    })
},1000),false);

================================================
JS执行上下文：https://www.cnblogs.com/echolun/p/11438363.html
1.执行上下文有且只有三类，全局执行上下文，函数执行上下文，与eval上下文
1.1全局执行上下文 一般由客户端浏览器创建如 window对象，全局对象window上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，
同时window对象还是var声明的全局变量的载体。我们通过var创建的全局对象，都可以通过window直接访问

1.2 函数执行上下文

在执行上下文的执行阶段，进行变量对象的赋值，函数的引用等


函数形参，是指函数声明时定义在圆括号里的形式参数，不是一个确切值。
函数实参，是指函数调用时提供的实际参数，是一个确切值，arguments指向实参引用，这个没问题。

function fn(){
	console.log(arguments)；
}

---------------------------------
js 编码规范：https://www.cnblogs.com/echolun/p/11408779.html
js 执行上下文：
https://www.cnblogs.com/shaunyang/p/10337099.html
https://www.cnblogs.com/lishuxue/p/6558788.html

执行上下文
1.全局执行上下文（JS代码加载完毕后，进入代码预编译即进入全局环境）
2.函数环境执行上下文（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
3.eval执行上下文（不建议使用，会有安全，性能等问题）

执行上下文重要属性
1.变量对象：存储了在上下文中定义的变量和函数声明
2.作用域链(Scope chain)，和原型链类似，当查找变量时，会先在当前上下文变量对象中查找，如果没有会去父级上下文变量对象中查找，直到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链
3.this

执行栈（调用栈）
具有 LIFO（后进先出）用于存储在代码执行期间创建的所有执行上下文
首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶
栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文

创建过程
创建变量对象（创建arguments对象，检查函数申明，检查变量申明）
创建作用链 将当前作用域添加至作用链顶端
确定this指向 (全局上下文指向window 函数根据情况指向)

1.创建arguments对象，检查当前上下文中的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
2.函数声明。检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。(function声明会比var声明优先级更高一点)。
3.变量声明。检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

变量提升的原因：
在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。
所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。
从创建顺序看，函数提升优先于变量提升。


执行阶段：完成对所有变量的分配，最后执行代码
变量赋值
函数引用
执行其他代码

------------------------------------
理解this的第一步就是要明白：this既不指向函数自身，也不指向函数的词法作用域；

this是在运行时进行绑定的，而不是在编写时绑定，它的上下文取决于函数调用时的各种条件；

this的绑定和函数声明的位置没有任何关系，只取决于函数的调用位置和调用方式；

this绑定规则有4点：按优先级1到4判断

1.由new调用？绑定到新创建的空对象；

2.由call、apply、bind调用？绑定到指定的参数对象；如foo.call(obj)

3.由上下文对象调用？绑定到这个上下文对象；如obj.foo()

4.默认情况下绑定到全局对象，foo()；在严格模式下绑定到undefined；

========================================================
this指向总结：
this是运行时绑定的，全局函数中的this是window（严格模式undefined），而当函数作为某个对象的方法调用时，this就是指的那个对象
1.对象中普通函数中的this指向的是对象，对象函数中嵌套的返回的匿名函数（闭包）指向window，对象函数是箭头函数指向的window
2.对象函数中嵌套返回的箭头函数没有自已的this，其this指向外部函数（外部上下文的this指向）
3.通过new对象或构造函数中，普通函数箭头函数指向对象，对象函数中嵌套的返回的匿名函数（闭包）指向window
4.可以通过apply call bind修改this(箭头函数除外)
5.函数中嵌套返回匿名闭包函数时，可以先将this赋值给一个变量，然后闭包访问这个变量
如：
let obj={
	 name:"objname",
	 get:function(){
	 		var that = this;
	 	  return function(){
	 	  	console.log(that.name)
	 	  }
	 }
}























变量提升是将变量声明提升到它所在作用域的最开始的部分

javascript代码执行过程分两个阶段
1.代码编译阶段 将代码翻译成可执行代码
2.代码执行阶段（由引擎完成）执行上下文会在这个阶段创建，
执行上下文（执行上下文可以理解为当前代码的执行环境，它会形成一个作用域）的创建也分创建阶段 及执行阶段






当调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。
创建阶段：在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。
代码执行：创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。


执行上下文（Execution Context）代码被解析或执行所在环境的抽象概念，（JavaScript中的运行环境）
全局执行上下文（JS代码加载完毕后，进入代码预编译即进入全局环境）
函数环境执行上下文（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
eval执行上下文（不建议使用，会有安全，性能等问题）
当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，
而栈顶就是当前正在执行的上下文。处于栈顶的上下文执行完毕之后，就会自动出栈。

对于每个执行上下文，都有三个重要属性：
1.变量对象(Variable object，VO)，存储了在上下文中定义的变量和函数声明。在全局执行上下文中指window，函数执行上下文中就是活动对象（AO）
2.作用域链(Scope chain)，和原型链类似，当查找变量时，会先在当前上下文变量对象中查找，如果没有会去父级上下文变量对象中查找，直到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链



词法环境，变量环境
变量对象  活动对象


<pre> 标签可定义预格式化的文本。
被包围在 <pre> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。

throttle/debounce
Reactive Extension 也叫 ReactiveX,或者简称Rx,指的是实践响应式编程的一套工具。Rx是一个大家族它包含 RxJava、RxPy等，RxJS是Rx用JavaScript语言实现。
RxJS是Rx用JavaScript语言实现


npm init 
在node开发中使用npm init会生成一个pakeage.json文件

setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。

Angular父子组件间传值
1.@Input 父组件传值给子组件
子组件中定义接收变量
@Input
hero: Hero; 

父组件中使用
<子组件引用名 [hero]="父组件中需要传值变量"></子组件引用名>

 
 

2.@Output 子组件传值给父组件
父组件中使用
<子组件引用名 (eventName)="emiterFun($event)"></子组件引用名>如下：
<app-price-quote (lastPrice)="priceQuoteHandler($event)"></app-price-quote><br>
<div>这是在报价组件外部，<br>
股票代码是{{priceQuote.stockCode}},
股票的价格是{{priceQuote.lastPrice | number:'2.2-6'}}</div>

父组件中定义接收方法如下：
export class AppComponent {
  // aaa = "";
  priceQuote: PriceQuote = new PriceQuote("", 0);
  // 书写一个方法接收$event,这个event的类型就是字组件emit发射过来的类型
  priceQuoteHandler(event) {
    this.priceQuote = event;
  }
}

子组件定义@Output如下：
@Output
lastPrice:EventEmitter<PriceQuote> = new EventEmitter();

constructor(){
  new priceQuote();
	this.lastPrice.emit(需要传的值或对对象priceQuote);
}


linux ftp服务
1. 首先服务器要安装ftp软件,查看是否已经安装ftp软件下：
#which vsftpd
如果看到有vsftpd的目录说明服务器已经安装了ftp软件

2. 查看ftp 服务器状态
#service vsftpd status

3. 启动ftp服务器
#service vsftpd start

4. 重启ftp服务器
#service vsftpd restart

5. 查看服务有没有启动
#netstat -an | grep 21
tcp 0 0 0.0.0.0:21 0.0.0.0:* LISTEN
如果看到以上信息，证明ftp服务已经开启。

6.如果需要开启root用户的ftp权限要修改以下两个文件
#vi /etc/vsftpd.ftpusers中注释掉root
#vi /etc/vsftpd.user_list中也注释掉root
然后重新启动ftp服务。


===============================
nginx

whereis nginx

nginx -t  //查看nginx 默认配置文件目录

/usr/sbin/nginx  //安装目录

systemctl status nginx.service

/bin/systemctl start nginx.service
/bin/systemctl stop nginx.service
/bin/systemctl restart nginx.service

nginx -c xxx/nginx.conf  //不加-c 则使用默认配置文件启动


# nginx指定配置文件启动
/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf


1.首先利用配置文件启动nginx。
命令:nginx -c /usr/local/nginx/conf/nginx.conf
重启服务：service nginx restart
2快速停止或关闭Nginx：nginx -s stop
3.正常停止或关闭Nginx：nginx -s quit
4. 配置文件修改重装载命令：nginx -s reload


获取yum安装rpm包

yum -y install --downloadonly --downloaddir=./ openssh   //获取openssh rpm包至当前目录下，且不安装仅下载

rpm -ivh *.rpm --nodeps --force  // cd 至当前目录后安装所有rpm包 不清楚rpm包依赖关系

 rpm -qa|grep openssl  //查询openssl 安装情况
 
 
 
------------------------------------------
linux yum 安装
yum list java*  //列出所有可安装的JAVA版本

yum install -y java具体版本

#rpm -qa|grep java  //安装后检查安装版本
#rpm -ql jenkins  //查看yum安装的JENKINS文件

卸载一个软件时 
yum -y remove httpd
卸载多个相类似的软件
yum -y remove httpd*
卸载多个非类似软件时
yum -y remove httpd php php-gd mysql

这时候需要用wget命令去网络上下载资源包
wget?http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo?-O /etc/yum.repos.d/epel-apache-maven.repo
然后重新安装maven????? ：yum -y install apache-maven


windows openssh
1.ssh-keygen -t dsa|rsa  生成密钥 (会生成id_dsa, id_dsa.pub 私公密钥对)
2.将公钥复制至远程电脑 ~/.ssh/authorized_keys 中如下：
 cat id_dsa.pub >> ~/.ssh/authorized_keys
3.ssh user@ip 即可


修改 sshd 服务配置(可修改端口等)
vi /etc/ssh/sshd_config 

systemctl status sshd.service  //查看sshd 服务状态
systemctl restart sshd.service //重启sshd 服务


ssh -p 8920 -i C:\Users\fang_houjun\.ssh\id_rsa root@10.30.32.12 -t "pwd;ls"   //-t 'pwd;ls'  创建虚拟交互终端 并执行pwd ls后返回

sftp -P 8920 -i C:\Users\fang_houjun\.ssh\id_dsa root@10.30.32.12   //-i 指定私钥文件位置

%cd%  //获取当前执行目录
%A:B=C%  // dos中 A:B=C的方式来替换字符串，具体含义就是在字符串变量A中查找所有的子串B并且替换成子串C

-----------------------------------
Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
一、获取对象中属性描述对象
--Object.getOwnPropertyDescriptor(obj, propName)
参数：第一个参数是目标对象，第二个参数是目标对象的目标属性。
返回值：该属性描述对象
如：
const obj = {
    item: 'hello',
    msg:'hi'
}
Object.getOwnPropertyDescriptor(obj, 'item')
{
    value: 'hello',
    writable: true,
    enumerable: true,
    configurable: true
}

二、获取对象中全部属性的属性描述对象
--Object.getOwnPropertyDescriptors(obj)
参数：想要获取的对象
返回值： 描述对象集合

三、属性描述对象的定义
--Object.defineProperty(obj, propName, descriptorObj)
参数：第一个参数目标对象，第二个参数是属性名，第三个参数是属性描述对象。
返回值： 修改后的对象
const obj = Object.defineProperty({}, 'item', {
  item: 'hello',
  writable: true,
  enumerable: true,
  configurable: true
});

// 当然，这样定义只是为了定义描述对象。
// 直接
obj.item = hello   // 最终也和上面一样

obj.item // "hello"
---------------------------------------------------------------------------------
JavaScript.descriptor(属性描述符) 参考：https://blog.csdn.net/weixin_30252709/article/details/97676560


Object.assign 深度复制
方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。

========================================================
typeScript 装饰器 //AOP的好处了，把和主业务无关的事情，放到代码外面去做
动态扩展额外的功能
避免继承的方式可能会导致子类繁多
在不改变接口的前提下，增强类的性能

装饰模式以对客户透明的方式动态的给一个对象附加上更多的功能。并且，客户端并不会觉得对象在装饰前和装饰后有什么不同。
装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展
Decorator 就是一个的包裹函数


js class  JavaScript构造函数的语法糖 //它可以看作是构造函数穿上了统一的制服，所以class的本质依然是函数，一个构造函数
class的本质是构造函数class的本质是构造函数class的本质是构造函数!!

class的body部分包含在花括号{}中，这里是定义class成员的地方
constructor方法是一个特殊的方法，用来创建并初始化一个对象。在一个class中只能有一个命名为constructor的特殊方法，如果包含多个将会报错。
constructor中可以通过super关键字，调用父类的constructor方法。


参考：https://blog.csdn.net/zhq2005095/article/details/80715551
修饰器是一个对类进行处理的函数。用来修改类的行为。
注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。
1.类的修饰器函数的第一个参数 target 指向类本身

2.修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。类是不会提升的，所以就没有这方面的问题。

原文链接：https://blog.csdn.net/u010958922/java/article/details/53584956
function decorateArmour(target, key, descriptor) {
  const method = descriptor.value;
  let moreDef = 100;
  let ret;
  descriptor.value = (...args)=>{
    args[0] += moreDef;
    ret = method.apply(target, args);
    return ret;
  }
  return descriptor;
}
其中，target是需要修改的对象；key是对象中的值；descriptor包含着这个值的内容，包括value、是否可读、是否可遍历等。
例如Decorator用于一个类的函数上，那么target就是这个类、key就是这个函数名、descriptor.value就是这个函数。



// @param  target 作用对象
// @param  prop  作用的属性名
// @param  descriptor 属性描述符
// @return descriptor 属性描述符
function decorator(target,prop,descriptor){}


====================================
linux yum安装指定版本node

需要安装不同版本的node仅需要替换setup_8.x 成setup_9.x即可

curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -    
sudo yum -y install nodejs


卸载node
yum remove nodejs npm -y

curl --silent --location https://rpm.nodesource.com/setup_9.x | sudo bash -

==============================================================================
数据库设计：
1.概念模型 use case 用例图 用例图由参与者参与者（Actor）、用例（Use Case）、系统边界、箭头组成，用画图的方法来完成
2.逻辑模型 ER图是实体-关系图 实体 属性 关系（对概念模型具体化）
3.物理模型

UML 


=======================================================
\t 相当于tab
\r 回车换行（将光标置至行首）
\n 换行



String.format();

0	显示数字，如果位数不够则补 0
#	显示数字，如果位数不够不发生变化

new Decimalformat("####.000").format(111.12)  // 111.120



java 千分位的添加和去除

将一个数字转换为有千分位的格式
NumberFormat numberFormat1 = NumberFormat.getNumberInstance();  
System.out.println(numberFormat1.format(11122.33)); //结果是11,122.33  
  
NumberFormat numberFormat2 = NumberFormat.getNumberInstance();  
numberFormat2.setGroupingUsed(false); //设置了以后不会有千分位，如果不设置，默认是有的  
System.out.println(numberFormat2.format(11122.33)); //结果是11122.33   


将一个可能包含千分位的数字转换为不含千分位的形式：
String amount1 = "13,000.00";  
double d1 = new DecimalFormat().parse(amount1).doubleValue(); //这里使用的是parse，不是format  
System.out.println(String.valueOf(d1)); //结果是13000.00  


String currecy = NumberFormat.getCurrencyInstance().format(1245600000);
System.out.println("转换成Currency格式："+currecy);

//将一个千分位分隔的带货币类型的数字串转化成数值
try {
    long dd =  new DecimalFormat().parse(currecy,new ParsePosition(1)).longValue();
    System.out.println(String.valueOf(dd));
} catch (Exception e) {
    e.printStackTrace();
}

java 数字格式化处理（小数点 百分号等）：https://blog.csdn.net/liu552726/article/details/9332957?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase


===================================================
java 数组 数组长度一旦声明,不可改变不可追加

整型数组初始化：
静态初始化：
int[] array = new int[]{1,2};
int[] temp = {1,3};           //简化方式
int temp[] = {1,3};    //这种方式也可以

动态初始化：
int[] array;  //先声明
array = new int[10];

int[] temp = new int[10];//合成一步


int[] arr;
arr = new int[10];
arr[0]=1;

int[] aa = new int[]{1,2};  //

int[] bb = new int[2];

-----------------------------------------------------------

javap是jdk自带的反解析工具

-------------------------------
format->NumberFormat->DecimalFormat

java1.5之后出现 ... 可变长参数 相当于可传0-N个参数的数组如下：
public void test(String ...name)

----------------------------------------------
jconsole使用

java 
-Djava.rmi.server.hostname=10.160.13.111  #远程服务器ip，即本机ip
-Dcom.sun.management.jmxremote #允许JMX远程调用
-Dcom.sun.management.jmxremote.port=3214  #自定义jmx 端口号
-Dcom.sun.management.jmxremote.ssl=false  # 是否需要ssl 安全连接方式
-Dcom.sun.management.jmxremote.authenticate=false #是否需要秘钥
 -jar test.jar 
 
linux 防火墙：https://blog.csdn.net/wade3015/article/details/90725871


1、在$JAVA_HOME/bin 下创建一个新文件  jstatd.all.policy，编辑该文件，填入内容：
grant codebase"file:${java.home}/../lib/tools.jar"{ permission java.security.AllPermission; };//若没有配置 JDK 环境变量，file 后面添加 tool.jar 的绝对路径

2、启动命令，默认监听1099端口并给该文件加上执行权限 chmod +x jstatd.all.policy

jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=127.0.0.1

要使用 VisualGC 必须在远程机上启动jstatd代理程序

/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64/bin

jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.logCalls=true &

https://www.cnblogs.com/qq931399960/p/10960573.html


java \
 -Djava.rmi.server.hostname=172.16.100.61 \
 -Dcom.sun.management.jmxremote.port=1566 \
 -Dcom.sun.management.jmxremote.authenticate=true \
 -Dcom.sun.management.jmxremote.ssl=false \
 -jar bosent_baseline_hot-deploy-SPRINGCLOUD-pcmsworkflow-161102-08-0.1-executable.jar &
 
 
--------------------------------------
java 性能监控工具
jps:jvm process status tool:显示指定系统中所有的hotspot虚机进程
jstat:jvm statistic monitoring tool) 收集hotspot虚拟机各方面的运行数据
jinfo:configuration info for java :显示虚拟机配置信息
jmap:memory map for java :生成虚拟机的内存转储快照heapdump文件
jstack：stack trace for java :显示虚拟机的线程快照
jconsole jmx的可视化工具
visualvm 可视化工具

jmap(查看内存):可以输出所有内存中的对象工具，也可以将VM中的堆文件以二进制形式输出成文本。
jmap -heap <pid>  //打印出PID进程对应的JVM堆内存heap配置及堆内存使用情况

jmap -finalizerinfo pid  //打印出PID进程对应内存准备回收的对象信息

jmap -dump:live,format=b,file=mydump.txt pid  //将pid进程对应JVM的heap内容到指定文件中

jmap -dump:format=b,file=heap pid

获取堆dump
1.启动参数配置outofmemory时触发打印堆快照
-XX:HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xx/xx/

2.jvm 命令：
jmap -dump:format=b,file=xxx.hprof <pid>  

查看所有对象的数量以及大小包括类型：jmap -histo 14116 | more
查看所有对象的数量以及大小包括类型：jmap -histo:live 14116 | more



64位机上使用需要使用如下方式：
jmap -J-d64 -heap pid


获取thread dump
kill -3 PID > some.file 2>&1

jstack [option] pid >> jstack.info  //获取thread dump文件

或 jstack -l pid >>d.txt
线程dump反映的是java虚拟所有线程在某一时刻的状态相信息。当前活动线程的快照



jstack(查看线程)

jstat(性能分析) Java Virtual Machine statistics monitoring tool
参考：https://www.cnblogs.com/shilimaixiang/p/13034871.html

jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]

jstat -class pid   //查看内加载情况

jstat -gc  pid  2000 20 //GC信息统计 每2秒统计一次，统计20次
S0C：第一个幸存区的大小
S1C：第二个幸存区的大小
S0U：第一个幸存区的使用大小
S1U：第二个幸存区的使用大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
OC：老年代大小
OU：老年代使用大小
MC：方法区大小
MU：方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间

jstat -gccause pid    //输出百分比+最近两次GC事件原因
jstat -gcnew  pid   //新生代行为统计
jstat -gcold  pid   //老年代行为统计

jstat -gccapacity pid   //堆使用情况统计
NGCMN：新生代最小容量
NGCMX：新生代最大容量
NGC：当前新生代容量
S0C：第一个幸存区大小
S1C：第二个幸存区的大小
EC：伊甸园区的大小
OGCMN：老年代最小容量
OGCMX：老年代最大容量
OGC：当前老年代大小
OC:当前老年代大小
MCMN:最小元数据容量
MCMX：最大元数据容量
MC：当前元数据空间大小
CCSMN：最小压缩类空间大小
CCSMX：最大压缩类空间大小
CCSC：当前压缩类空间大小
YGC：年轻代gc次数
FGC：老年代GC次数

jstat -gcnewcapacity pid //新生代堆使用情况








当堆内存空间溢出时输出堆的内存快照。
加参数-XX:HeapDumpOnOutOfMemoryError

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/home/tomcat/logs/...

java.lang.OutOfMemo-ryError: Java heap space
也就是说当发生OutOfMemoryError错误时，才能触发-XX:HeapDumpOnOutOfMemoryError 输出到-XX:HeapDumpPath指定位置。

=============================================================================================================
jstatd
jstatd是一个rmi的server应用，用于监控jvm的创建和结束，并且提供接口让监控工具可以远程连接到本机的jvm 。jstatd位于 $JAVA_HOME/bin目录下
jstatd是一个监控 JVM 从创建到销毁过程中资源占用情况并提供远程监控接口的 RMI （ Remote Method Invocation ，远程方法调用）服务器程序，
它是一个 Daemon 程序，要保证远程监控软件连接到本地的话需要 jstatd 始终保持运行。

jmx
JMX：Java Management Extensions ，即 Java 管理扩展 , 是一个为应用程序、设备、系统等植入管理功能的框架。 JMX 可以跨越一系列异构操作系统平台、
系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用 。而Visual VM是通过 JMX 来和远程 Java 应用联系的


检查hostname -i 检查系统IP

服务器端启动jstatd 服务（java.home/bin目录下）：
./jstatd -J-Djava.security.policy=jstatd.all.policy \
-J-Djava.rmi.server.hostname=10.30.32.5 \
-J-Djava.rmi.server.logCalls=true &

[root@localhost bin]# ./jstatd -J-Djava.security.policy=jstatd.all.policy   //默认就是1099
./jstatd -J-Djava.security.policy=/root/jstatd.policy -p 2099   //指定端口2099

要使Java VisualVM 成功连接到远程服务器上，服务器端应该在 /etc/hosts 文件中把本机地址设为本机的 IP 地址。
使用 hostname -i 命令查看，如果显示的是 127.0.0.1 或者与本机实际 IP 不一致的话，需要把 /etc/hosts 文件中相应的地址改为本机实际 IP 。
[root@localhost ~]# jstatd -J-Djava.security.policy=/root/jdk1.8.0_144/bin/jstatd.all.policy -J-Djava.rmi.server.logCalls=true



备注：-J-Djava.rmi.server.logCalls 启用日志

jvisualvm 连接 jstatd 远程监控 jvm 或 Visual GC提示"不受此JVM支持“ 解决方案如下：
服务端启用jstatd时指定安全策略文件如下：

创建安装策略文件jstatd.all.policy：
grant codebase "file:${java.home}/../lib/tools.jar"{
 permission java.security.AllPermission;
};

或绝对路径：
grant codebase "file:/opt/jdk1.8.0_221/lib/tools.jar"{
 permission java.security.AllPermission;
};

启动后可通过如下方式连接测试：
jps -l rmi://10.30.32.5:1099  连接上指定服务器查看虚机进程



jconsole visualvm 用户密码设置
jdk\jre\lib\management\jmxremote.password.template 复制一份为jmxremote.password
cp -r jmxremote.password.template jmxremote.password
修改：去掉# 启用配置
monitorRole  QED
controlRole  R&D

修改文件权限：chmod 600 jmxremote.password

-------------------
jconsole 时需一定要加-Dcom.sun.management.jmxremote=true参数

java -Dcom.sun.management.jmxremote.port=6969 -Dcom.sun.management.jmxremote.ssl=false \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.pwd.file=/opt/jdk1.8.0_221/jre/lib/management/jmxremote.password \
-Dcom.sun.management.jmxremote.access.file=/opt/jdk1.8.0_221/jre/lib/management/jmxremote.access \
-Djava.rmi.server.hostname=10.30.32.5 \
-Dcom.sun.management.jmxremote=true \
-jar xxx.jar




visualvm 连接远程服务：
https://www.cnblogs.com/qq931399960/p/10960573.html
https://www.cnblogs.com/grey-wolf/p/9234780.html
https://blog.csdn.net/weixin_33910460/article/details/92958822?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase





启动后查看
netstat -lpnt|grep jstatd

jps





jmx连接
两种地址
1、ip:port
2、jmx service url (service:jmx:rmi:///jndi/rmi://192.168.3.15:9999/jmxrmi)
service:jmx:rmi:///jndi/rmi://localhost:7091/jmxrmi
service:jmx:rmi:///jndi/rmi://<hostname>/jmxrmi

java 连接代码
public static void main(String[] args) {
		String hostName = "192.168.88.106";
		int portNum = 10089;
		
		try {
			JMXServiceURL u = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" 
					+ hostName + ":" + portNum + "/jmxrmi");
 
			Map<String, Object> auth = new HashMap<String, Object>();
			auth.put(JMXConnector.CREDENTIALS, new String[] { "controlRole", "R&D" });
 
			JMXConnector c = JMXConnectorFactory.connect(u, auth);
		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
 
	}


=====================================================
GC时会暂停整个JAVA应用，普通GC 只是对年轻代进行垃圾回收，full的GC会对整个堆内存（包含老年代、年轻代）进行垃圾回收。system的GC显示调用GC。
full gc 只会在两个情况下发生：1）system.gc被显示调用时，会执行full gc。2）老年代的堆内存满时，会执行full gc。








-----------------------
jps -l //查看本机所有java进程pid

线程dump反映的是java虚拟所有线程在某一时刻的状态相信息。当前活动线程的快照

top // 查看占用CUP进程情况
top -H -p <pid> 或 top -Hp pid  //查看cpu占用高线程
print "x%\n" <pid>  转化pid成16进制以例dump文件中查找定位

jstack pid |grep -A 20 xxxx

---------------------------------------linux下如何定位代码问题-------------------------------
top获取进程id
获取线程消耗cpu最多的线程 top -Hp pid
printf "%x\n" pid 转化线程ID为16进制
jstack pid |grep -A 20 16进制id




1、先通过top命令找到消耗cpu很高的进程id假设是123

2、执行top -p 123单独监控该进程

3、在第2步的监控界面输入H，获取当前进程下的所有线程信息

4、找到消耗cpu特别高的线程编号，假设是123

5、执行jstack 123456对当前的进程做dump，输出所有的线程信息

6、将第4步得到的线程编号11354转成16进制是0x7b

7、根据第6步得到的0x7b在第5步的线程信息里面去找对应线程内容

8、解读线程信息，定位具体代码位置

-----------------------------分割线----------------------------------------------------------
获取线程dump信息 thread dump方法
方法一：jstack [option] pid
--参数
1. -F 强制打印堆栈
2. -m 打印java 和 native（C++） 堆栈信息  
3. -l 打印额外的信息，包括锁信息

方法二：
kill -3 pid

备注：查找JAVA进程：
jps 或 ps -ef|grep java



Java语言中的线程是依附于操作系统的线程来运行的，从本质上来说是本地线程在执行java线程代码，从JVM源码角度分析，在Java中创建线程是，
实际上创建一个os thread，这个os才是真正的线程实体。
关于jvm虚拟机线程创建感兴趣的可以参考该链接：https://www.jianshu.com/p/3ce1b5e5a55e

thread dump 包含信息(线程的状态和其执行堆栈)：
线程的名字，ID，线程的数量等。
线程的运行状态，锁的状态(锁被哪个线程持有，哪个线程再等待锁等)。
调用堆栈(函数的调用层次关系)。调用堆栈包含完整的类名，执行的方法，源代* 码的行数

守护进程：创建线程的时候可以设置线程是否是守护进程。
优先级：线程创建的时候设置线程的优先级，一般采用默认值
线程id（tid）：JVM给线程分配的id号
本地线程id（nid）：对应的os 线程的线程id，可以将16进制转换为10进制，在os中找到对应的线程
线程状态：这线程堆栈日志中，一个线程就waiting 状态和 runnale两种状态
线程内存地址：线程起始地址




free -h -s n //每N秒显示内存使用情况

------------------------------------
程序计数器（线程私有，每一个线程都有独立计算器；生命周期同线程的创建而创建，随线程结束而死亡）：每个线程在创建后，都会产生自己的程序计算器及栈桢，
程序计算器主要是用来存放执行指令偏移量及行号指示器，线程的执行及恢复都要依赖程序计数器。

java堆（oom故障发源地，所有线程共享）：存放实例对象，堆由垃圾回收集器自动回收，堆由各子线程共享使用。堆内存空间可以固定大小也可以运行时动态调整
-Xms256m(最小堆容量) -Xmx1024m（最大堆容量）JVM的Xms和Xmx设置成一样大小，一定程序上避免GC后调整堆大小带来额外压力。
当线程请求分配内存，但堆内存已满且内存已满且无法再扩展时就抛出OutOfMemoryErro.


堆分为两大块：新生代及老年代
新生代=1个Eden区+2个Survivor区（from区，to区）默认8:1:1

Young GC
Full Garbage Collection(Full GC)

当堆内存空间溢出时输出堆的内存快照。
加参数-XX:HeapDumpOnOutOfMemoryError

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/home/tomcat/logs/...

备注：
堆是所有线程共享
程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个

Metaspace(元空间) 前称JDK7及之前版本只有Hotspot才有Perm区（永久代）
outOfMemoryError 年老代内存不足。
outOfMemoryError:PermGen Space 永久代内存不足。
outOfMemoryError:GC overhead limit exceed 垃圾回收时间占用系统运行时间的98%或以上。
outOfMemoryError:java heap space 堆内存不足


JVM将内存根据分代策略将内存分为三层：新生代，老年代，永久代（非堆永久代）
新生代from to 复制算法，不产生内存碎片，保证永远有一个survivor space是空的，另一个非空的survivor space无碎片
每个对象在坚持过一次Minor GC之后，年龄就加1

分代的意义，提高GC效率
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生
设置两个Survivor区最大的好处就是解决了碎片化

新生代是 GC 收集垃圾的频繁区域

JVM主要管理两种类型的内存：堆和非堆

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据(线程私有)；
堆解决的是数据存储的问题，即数据怎么放、放在哪儿（堆所有线程共享）。




64位机上使用需要使用如下方式：
jmap -J-d64 -heap pid

内存分析工具(Memory Analysis Tool）或与jhat (Java Heap Analysis Tool)


-----------------------------------------------------------
方法区：
方法区和永久代的关系很像Java中接口和类的关系，永久代是Sun公司HotSpot虚拟机对虚拟机规范中方法区的一种实现方式

JDK1.8之前调节方法区大小：
-XX:PermSize=N //方法区（永久代）初始大小
-XX:MaxPermSize=N //方法区（永久代）最大大小，超出这个值将会抛出OutOfMemoryError 

JDK1.8开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本机内存。参数设置：
-XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小


栈JVM stack:栈是java 方法执行的内存模型
堆：java heap :所有的对象实例以及数组都要在堆上分配，此内存区域的唯一目的就是存放对象实例
堆结构：新生代（Eden区+2个Survivor区）  老年代   永久代（HotSpot有）


JVM运行时内存划分为：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区。可以简记为：一计两栈一堆一区

YGC 在新生代中进行，首先要清楚新生代的堆结构划分。新生代分为Eden区和两个Survivor区，其中Eden:from:to = 8:1:1 (比例可以通过参数 CXX:SurvivorRatio 来设定 )，这是最基本的认识。

--------------------------------
jvm 堆配置：

堆设置
-Xms:初始堆大小 默认为物理内存的1/64
-Xmx:最大堆大小 默认为物理内存的1/4
-Xmn:新生代大小 通过这个值也可以得到老生代的大小：-Xmx减去-Xmn

备注：
-Xss：栈大小，设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，
当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，
特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。
（栈中存放数据过多，大量递归 java.lang.StackOverflowError）

-XX:NewRatio:设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3
-XX:SurvivorRatio:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5??
-XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代
-XX:PermSize、-XX:MaxPermSize:分别设置永久代最小大小与最大大小（Java8以前）
-XX:MetaspaceSize、-XX:MaxMetaspaceSize:分别设置元空间最小大小与最大大小（Java8以后）
收集器设置
-XX:+UseSerialGC:设置串行收集器
-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行老年代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器
垃圾回收统计信息
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:filename
并行收集器设置
-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
并发收集器设置
-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
-XX:ParallelGCThreads=n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。
――――――――――――――――
java 堆与栈

栈解决的程序运行问题，即程序如何执行，或者说如何处理数据；
堆解决的是数据存储问题，即就是数据如何放、放哪儿
从软件设计角度分析，栈代表了处理逻辑，堆代表了数据，这样分开，使得处理逻辑更清晰
堆和栈的分离，使得堆的内容可以被多个栈共享（即多个线程访问同一个对象）
面向对象就是堆和栈的完美结合，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。
每当一个新的线程被创建时（线程结束，栈内存就释放了。不存在垃圾回收问题）。Java 虚拟机都会分配一个虚拟机栈，Java虚拟机栈是以帧为单位来保存线程的运行状态。Java栈只会有两种操作：以帧为单位进行压栈跟出栈

栈及堆的优缺点：
1.堆线程共享是一个运行时数据区，类的对象实例从中分配空间，不需要程序显示的释放内存空间，由垃圾回收来负责；堆可以动态分配大小，生命周期不用事先告诉编译器；由于动态分配内存，所以存取速度较慢。
2.栈线程私有的，栈主要存放一些基本的变量（int,short,char,long,byte,float,double,boolean）及对象句柄。栈的优点是存取速度比堆快，仅次于寄存器，缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性

java把内存划分为 栈内存及堆内存

变量在栈中分配内存，同时存放在堆中的数组或对象的引用变量也在存放在栈中。超出变量作用域后，java会自动释放掉栈中分配的内存空间
堆内存放new 创建的对象及组数，堆中分配的内存由GC来管理

备注：引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象






栈
栈桢：局部变量表，操作数栈，动态链接，方法出口
栈不存在垃圾回收，线程私有，生命周期根据线程，会StackOverflowError



备注：
java的数据类型分为两种：基本类型和引用类型。基本类型的变量保存的是原始值，
引用类型的变量保存的是引用值。引用值代表某个对象的引用，而不是对象本身，对象本身放在这个引用值所表示的地址的位置

运行时数据区（内存模型）

==========================================================================
通过visualVM程序监控JVM，JDK 1.6中自带的可视化监控工具，这个工具比较实用，功能也比较强大。可以监控线程信息，堆内存信息，
还可以实时导出堆信息以及强制GC。监控本地JVM直接启动该工具后就可以监控，远程监控需要启动jstatd和jrxml。

启动jstatd方法：新建jstatd.all.policy文件，添加如下内容，tools.jar包的路径根据实际情况修改：
grant codebase "file:/home/ndmc/tomcat/jdk/jre/lib/tools.jar" {
   permission java.security.AllPermission;
};

执行启动命令./jstatd -J-Djava.security.policy=jstatd.all.policy，默认端口为1099，后面可跟-p指定其他端口号
使用jrxml远程监控JVM的时候需要加上以下参数：
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=8849
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
-Djava.rmi.server.hostname=hostip
====================================================================
JVM管理的几个内存区域包括以下几个内存区域：

1、  方法区（包含运行时常量池 JDK1.7之前->permspace 永久代 JDK1.8 MetaSpace 元空间）：用于存储JAVA类信息、常量、静态变量。这个区域也可以发生垃圾回收，比如当一些类不在被引用时JVM可以卸载这个类，不过这种回收动作很少发生。另外所有线程都共享方法区，因此线程对方法区的访问被设计为线程安全的。

2、  虚拟机栈：JAVA虚拟机栈是线程私有的，每当启动一个新线程时，JVM都会为它分配一个JAVA虚拟机栈。没当线程调用方法时，JVM都会为虚拟机栈压入一个栈帧，该栈帧用于存储参数、局部变量、中间运算结果、方法出口等。

3、  本地方法栈：和虚拟机栈类似，只是他是专为JAVA中的Native方法服务。当线程进入本地方法后，它已经脱离的JVM的限制，甚至可以直接使用本地处理器中的寄存器。实际上本地方法的调用机制非常依赖于JVM的具体实现。

4、  堆：由JVM启动时创建，由所有线程共享，用于存放对象的实例。一般情况下它是JVM中管理的内存中最大的一块。绝大部分JVM内存问题都发生在这一块。

5、  程序计数器：同虚拟机栈一样，它也是线程私有，启动线程是创建。程序计数器的中保存的内容总是下一条将被执行的指令的地址。


这几个内存区域，除了程序计数器区域外，其他几个区域都有可能发生内存溢出问题。常见的内存溢出有两种：
1、方法区溢出。出现该问题时，JVM会报如下类似错误：java.lang.OutOfMemoryError : PermGenSpace ，Perm区的最大内存大小可以通过-XX:MaxPermSize=指定。引起这类内存溢出原因一般有两个，一个是常量池太大，一个是需要加载的CLASS类太多。出现问题的时候排查下这两种可能性，问题可以很快找到。这类问题程序稳定后也很少出现。
2、堆内存溢出。在JVM可使用的最大堆内存可以在启动的时候通过-Xmx参数指定。堆内存溢出是最为常见的内存溢出问题，发生堆内存溢出时，JVM会报告如下错误：java.lang.OutOfMemoryError : java heap space。
这里列举下在定位堆内存溢出时，常见的方法和思路。堆内存溢出顾名思义就是，堆内存不够用了，如果程序设计的最大对内存已经耗尽，那说明程序设计存在问题，不该申请很多内存的逻辑申请了很多的内存，该释放的对象没有释放。最重要的问题是就要要找出到底是什么对象没有及时释放，导致占用了过多的内存。常见的方法：
a、  一个强大的定位工具是使用 jprofiler，通过jprofiler可以实时的监控到，当前的堆内存的总体使用情况及当前存活的对象、大小、分配树、对象引用链等等，功能非常全面


---------------------------------------------------------
常见内存溢出问题：
java.lang.OutOfMemoryError: Java heap space 堆内存溢出
java.lang.OutOfMemoryError: PermGen space  方法区内存溢出
java.lang.OutOfMemoryError: GC overhead limit exceeded  垃圾回收时间占用系统运行时间的98%或以上 //GC占用了多余98%（默认值）的CPU时间却只回收了少于2%（默认值）的堆空间


在 JDK 1.7 之后(包括1.7)，字符串常量池已经从方法区移到了堆中

Java是使用 双亲委派模型 来进行类的加载的
双亲委托模型的工作过程是：　　

　　如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，
　　而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的
　　启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，
　　子加载器才会尝试自己去加载。

使用双亲委托机制的好处是：
　　能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。

三种JVM
hotspot(Sun公司),JRockit(BEA公司的JRockit),J9VM(IBM公司)

JDK包含JRE包含JVM

-----------------------------------------------
栈：存放基本类型变量，对象引用变量；（栈帧：局部变量表，操作数栈，动态链接，方法出口）
堆：存放有new创建的对象和组数
小结：堆是来存放对象，栈是用来执行程序的

方法区：跟堆一样被所有线程共享，主要存放类信息，常量，静态变量
程序计数器：字节码执行指令地址

符号引用
在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类要引用org.simple.Tool类，
在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 
的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址.

volatile修饰变量。在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

类从被加载到内存中开始，到卸载出内存为止。它的生命周期总共七个阶段：加载---->验证---->准备---->解析---->初始化---->使用---->卸载
符号引用将在解析阶段被替换为直接引用

Java6和6之前，常量池是存放在方法区（永久代）中的。
Java7，将常量池是存放到了堆中。
Java8之后，取消了整个永久代区域，取而代之的是元空间。运行时常量池和静态常量池存放在元空间中，而字符串常量池依然存放在堆中。


========================================================================================================
JVM:java virtual machine  java虚拟机，一种软件实现，整个JAVA的实现跨平台运行的核心部分；可以运行class格式的类文件，JVM屏蔽了平台，使java程序只运行在各自平台的虚机上，从而实现
一个CLASS文件跨平台运行。

JDK->JRE-JVM  java开发工具包-》java运行环境-》java虚拟机

jvm实例 对应一个独立运行的JAVA程序 每个java程序都运行它自己的jvm实例，当一个java程序启动时，一个jvm实例诞生，当该程序关闭时，jvm实例随之消亡。

CLASS文件（Byte-code字节码文件）：各种不同平台的虚拟机和平台都统一使用一种存储格式-字节码，是和平台无关的基石
class文件是一组以8位字节为基础单位的二进制流，class文件并不是机器语言而是二进制文件（机器语言指的是硬件能直接运行的二进制指令代码）


常量池存放内容：
1.字面量： 文本字符串，申明为final的常量值
2.符号引用：
 类和接口的全限定名
 字段名称和描述符
 方法名称和描述符


------------------
2.5. Run-Time Data Areas
2.5.1. The pc Register
2.5.2. Java Virtual Machine Stacks
2.5.3. Heap
2.5.4. Method Area（包含Run-Time Constant Pool）
2.5.5. Run-Time Constant Pool
2.5.6. Native Method Stacks
-----------------------------------------


Class类文件的结构
１.无符号数
２.表
无符号数属于基本的数据类型:
u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节，8个字节的无符号数。
表是由多个无符号数或者其它表作为数据项构成的复合数据类型，以_info结尾


JVM Class字节码文件格式：
ClassFile {
    u4 magic;    //4个字节 CAFFBABE
    u2 minor_version; //2个字节 次版本号
    u2 major_version; //2个字节 主版本号45开始jdk1.1  46 jdk1.2
    u2 constant_pool_count; //2个字节 常量池容量
    cp_info constant_pool[constant_pool_count-1]; //常量表 从下标1开始，0为不使用常量
    u2 access_flags; 
    u2 this_class; 
    u2 super_class; 
    u2 interfaces_count; 
    u2 interfaces[interfaces_count]; 
    u2 fields_count; 
    field_info fields[fields_count]; 
    u2 methods_count; 
    method_info methods[methods_count]; 
    u2 attributes_count; 
    attribute_info attributes[attributes_count]; 
}

JVM 常量池类型
类 型															标 志	描 述
CONSTANT_utf8_info								1	UTF-8编码的字符串
CONSTANT_Integer_info							3	整形字面量
CONSTANT_Float_info								4	浮点型字面量
CONSTANT_Long_info								5	长整型字面量
CONSTANT_Double_info							6	双精度浮点型字面量
CONSTANT_Class_info								7	类或接口的符号引用
CONSTANT_String_info							8	字符串类型字面量
CONSTANT_Fieldref_info						9	字段的符号引用
CONSTANT_Methodref_info						10	类中方法的符号引用
CONSTANT_InterfaceMethodref_info	11	接口中方法的符号引用
CONSTANT_NameAndType_info					12	字段或方法的符号引用
CONSTANT_MethodHandle_info				15	表示方法句柄
CONSTANT_MothodType_info					16	标志方法类型
CONSTANT_InvokeDynamic_info				18	表示一个动态方法调用点

常量
cp_info{
	u1 tag  //JVM通过tag位确定该常量池项表示什么类型的符号引用
	info[] //若干字节组成的info数组 可以是数值 也可以是索引
}

CONSTANT_Methodref_info { 
    u1 tag; 
    u2 class_index;  //表示引用这个方法的对象在常量池数组中的索引
    u2 name_and_type_index; //表示方法类型及名称在常量池数组中的索引
}

CONSTANT_Class_info {
     u1 tag; 
     u2 name_index; //类名称在常量池数组中的索引
}







一个线程--》表示一个JAVA虚拟机栈；
方法的执行--》可以通过压栈的方式--》方法对应栈帧

-------------------------------
类加载:
类加载器：
系统类加载器（应用类加载器）
可扩展类加载器
根类加载器

双亲委派机制，保证类的安全！
所有类的加载都会委托父类直到最顶层，在顶层开始寻找有没有这个类，如果有这个类就直接加载这个类；没有，就向下查找，直到找到位置。



JNI:java native interface java本地方法接口
native


ORM一般指对象关系映射。对象关系映射（Object Relational Mapping，简称ORM）


类加载过程：装载（查找类文件） 链接（验证，准备，解析：将CLASS文件的符号引用转化为直接引用） 初始化 使用 卸载



Linux scp 命令用于 Linux 之间复制文件和目录。

从远程复制到本地
scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 

从本地复制到远程
scp local_file remote_username@remote_ip:remote_folder 
或者 
scp local_file remote_username@remote_ip:remote_file 
或者 
scp local_file remote_ip:remote_folder 
或者 
scp local_file remote_ip:remote_file 
-----------------------------------------------------
java -jar myapp.jar --spring.profiles.active=dev




-------------------------------------------------------------
jmm 相关参考：
http://www.blogjava.net/DLevin/archive/2011/09/05/358033.html
https://blog.csdn.net/weixin_42762133/article/details/103241439

在sun提供的hotSpot虚拟机中，包括了启动类装载器、扩展类装载器、系统类装载器、用户定义类装载器

当遇到new（使用new关键字实例化对象）、getstatic（读取一个类的非final修饰静态字段）、putstatic（设置一个类的静态字段）、invokestatic（调用一个类的静态方法）方法时，
对相应的类执行初始化操作
解析阶段是JVM将常量池内的符号引用替换为直接引用的过程（此时与验证阶段存在交叉关系）

一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址


访问权限修饰符：https://blog.csdn.net/qq_37499840/article/details/89218587

final―终态类，表示该类不能被继承

成员变量修饰符
    public（公共访问控制符）: 指定该变量为公共的，他可以被任何对象的方法访问。

    private（私有访问控制符）: 指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。

    protected（保护访问控制符）: 指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。

    friendly: 在同一个包中的类可以访问，其他包中的类不能访问。

    final: 最终修饰符，指定此变量的值不能变。

    static（静态修饰符）：指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。

    transient（过度修饰符）：指定该变量是系统保留，暂无特别作用的临时性变量。

    volatile（易失修饰符）：指定该变量可以同时被几个线程控制和修改。

方法修饰符
    public（公共控制符）

    private（私有控制符）: 指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）

    protected（保护访问控制符）：指定该方法可以被它的类和子类进行访问。

    final:指定该方法不能被重载。

    static：指定不需要实例化就可以激活的一个方法。

    synchronize: 同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。

    native：本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。



public class A{
  static{
  	System.out.println("static init!")
  }
}

Class.forName("A",true,this.getClass().getClassLoader()) 等同 Class.forName("A") 等同 new A() 加载类并初始化
总结：
 不初始化则不会执行static块
 Class.forName("A",false,this.getClass().getClassLoader())   //加载类A 但不初始化，不会执行static









=========================================================

mysql 查询所有表
select table_name,table_rows,table_comment from information_schema.tables where table_schema='product_dev' order by table_rows desc;


统计所有表的数据量情况
select * from survey
select concat(
'select "',
TABLE_name,
'", count(*) from ',
TABLE_SCHEMA,
'.',
TABLE_name,
' union all'
) from information_schema.tables
where TABLE_SCHEMA='product_dev';
