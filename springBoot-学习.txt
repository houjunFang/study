1.要成为一个springboot项目必须继承spring-boot-starter-parent同时指定版本
2.覆盖指定相关参数如下：
  <properties>
      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
      <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
      <java.version>1.8</java.version>
      <start-class>com.hjapp.springbootdemo.SpringbootdemoApplication</start-class>
  </properties>
3.组件依赖不用配置版本，因为parent中已经有指定如下：
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
4.maven插件也在spring-boot-starter-parent中有指定所以可直接如下使用
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
启动类可通过属性start-class来配置指定


controller配置正常报404错解决方案：
1.spring boot 默认扫描您的类是 在启动类的当前包 和 下级包
2.还有一种解决方案是 ，配置spring 扫描路径 在启动类的上面添加   @ComponentScan(basePackages = {"com.dai.*"}),这配您的controller所在的包  

=======================================================================================================================================
SpringBoot 集成swagger2
1.pom.xml中增加如下swagger依赖
 <!--swagger2 支持-->
  <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger2</artifactId>
      <version>2.2.2</version>
  </dependency>
  <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger-ui</artifactId>
      <version>2.2.2</version>
  </dependency>
2.xxxApplication同级位置创建如下swagger2.java
@Configuration
@EnableSwagger2 //启用swagger2
public class Swagger2 {

    @Bean
    public Docket createRestApi(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.hjapp.controller")) // 扫描该包下的所有需要在Swagger中展示的API，@ApiIgnore注解标注的除外  
                .paths(PathSelectors.any())
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("Spring Boot集成Swagger2构建RESTful APIs DEMO")
                .description("springBoot集成swagger2 DEMO")
                .termsOfServiceUrl("http://www.hjapp.com/")
                .contact("fanghoujun")
                .version("1.0")
                .build();
    }
}
3.针对com.hjapp.controller包下的controller相应方法作相应注解配置如下：
@RestController
public class TestController {

    @ApiOperation(value="支付工具名称名称查询",httpMethod = "POST",notes = "用户测试验证 <br> 接口生成时间：2018年07月12日 13:31:54",consumes = "application/json", produces = "application/json")
    @RequestMapping(value ="/getUser",method= RequestMethod.POST)
    @ApiImplicitParam(name = "User", value = "user服务参数", required = true, dataType = "User")
    public String getUser(@RequestBody User user){//@RequestBody 绑定JSON字符串至对象user
        return "hello test";
    }
}
---------------------------------------------------------------
入参中使用的bean
@ApiModel(description="输入bean")
public class User {

    @ApiModelProperty(name="userName", value="姓名",dataType="String",example="aaa")
    private String name;
    @ApiModelProperty(name="age", value="年龄",dataType="String",example="18")
    private String age;

    @ApiModelProperty(name="id", value="id",dataType="String",example="2018009")
    private String id;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

}
4.启动项目后通过http://ip:端口/swagger-ui.htm访问查看生成的api效果
http://127.0.0.1:8080/v2/api-docs

5.关键注解说明：

属性说明
@ApiModelProperty(value="字段说明中文描述",name="属性名称",dataType="类型",required="true/false是否必填",example="样例")

====================================================================================================================
@SpringBootApplication注解，它包括三个注解：
@Configuration：表示将该类作用springboot配置文件类。
@EnableAutoConfiguration:表示程序启动时，自动加载springboot默认的配置。
@ComponentScan:表示程序启动是，自动扫描当前包及子包下所有类。


@Controller 普通controller，返回视图
@RestController 直接返回字符串 相当于@ResponseBody + @Controller

返回空
response.getWriter().print(null);


@CrossOrigin

@ResponseBody
@RestController









js中JSON.stringify()用在ajax中将json对象转化成JSON字符串形式传输
JSON.parse()【从一个字符串中解析出json对象】
JSON.stringify()【从一个对象中解析出字符串】
JSON.stringify()函数是用来序列化对象的，无论输入什么，输出的都是字符串类型，可以按自己的需求来定制如何序列化，输出结果是怎样的格式
//测试发送json数据
$("#id").click(function () {
    $.ajax({
        type: "post",
        url: "test",
        contentType: "application/json; charset=utf-8",
        data: JSON.stringify(getTestJson()),
        dataType: "json",
        success: function (data) {
            alert(data);
        },
        error:function (XMLHttpRequest, textStatus, errorThrown) {
            alert(XMLHttpRequest.status);
            alert(XMLHttpRequest.readyState);
            alert(textStatus);
        }
    });
 
    function getTestJson() {
        var Json = {
            "a":"aaaaaaa",
            "b":0,
            "c":2,
        };
        return Json;
    }
 
});


 @RequestBody(required = false)非必传处理
 
 @RequestMapping(value = "/test",method = RequestMethod.POST)
    @ResponseBody
    public String test(@RequestBody(required = false) String requestJson){
            if(requestJson==null||requestJson==""){
                return ApiResponse.buildFailResponse(ResultConstant.OPERATOR_FAIL,"请求接口需要传递正确的JSON数据");
            }

---------------------------------------------------------------------------------------------------------
@ImportResource 加载配置文件
@ImportResource({"classpath*:META-INF/core-app/*.xml", "classpath*:META-INF/productCenter/productCenter-service.xml"})

@SpringBootApplication 指定扫描包：scanBasePackages
@SpringBootApplication(
    scanBasePackages = {"com.bosent.productCenter"}
)


单元测试
@RunWith //默认使用SpringRunner.class

指定runner 
@RunWith(SpringRunner.class)

@SpringBootTest(classes={Application.class})// 指定启动类



@SpringBootApplication
@SpringBootApplication

@ImportResources
@SpringBootTest
@RunWith



==============================================================
SpringBoot启动

1.方式一
@SpringBootApplication
public class App{
	public static void main(String args[]){
		SpringApplication.run(App.class,args);
	}
}

2.方式二
@SpringBootApplication
public class App{
	public static void main(String args[]){
		SpringApplication sp = new SpringApplication(App.class);
		sp.run(args);
	}
}

-----------------------------------------------------------
SpringBoot测试 https://www.zhihu.com/collection/188110676

@RunWith(SpringRunner.class)
@SpringBootTest
public class XxxTestClassName{

}
说明：
1.@RunWith(SpringRunner.class) 等价 @RunWith(SpringJUnit4ClassRunner.class) SpringRunner是SpringJUnit4ClassRunner的一个别名,简写，继承关系。
其作用为自动创建spring应用上下文，启用spring容器环境，直白说就是启用spring容器环境来运行测试代码。
2.SpringBootTest 作用以@SpringBootApplication标解的类实体作为入口，加载配置并初始化上下文环境。

-------------------------------------------------------------------------------------------------------



@SpringBootTest  //默认会使用SpringBootContextLoader类用于上下文加载,不需要手动增加@ContextConfiguration(loader=...)指定加载配置，可以自定义配置

@SpringBootTest的作用

其代码注释如下：
Annotation that can be specified on a test class that runs Spring Boot based tests. 
Provides the following features over and above the regular Spring TestContext Framework: 

1. Uses SpringBootContextLoader as the default ContextLoader when no specific @ContextConfiguration(loader=...) is defined. 
2. Automatically searches for a @SpringBootConfiguration when nested @Configuration is not used, and no explicit classes are specified. 
3. Allows custom Environment properties to be defined using the properties attribute. 
4. Provides support for different webEnvironment modes, including the ability to start a fully running container listening on a defined or random port. 
5. Registers a TestRestTemplate bean for use in web tests that are using a fully running container. 

要点
1.默认会使用SpringBootContextLoader类用于上下文加载，
这个类将会使用所配置的SpringBootApplication实体类作为入口，加载配置并初始化Spring上下文环境；

2.可以支持自定义的配置，通过 Environment 属性设置；

3.支持不同的 web 环境模式，可以是固定端口、随机端口、无端口几种模式。




@RunWith
当一个类用@RunWith注释或继承一个用@RunWith注释的类时，JUnit将调用它所引用的类来运行该类中的测试而不是开发者去在junit内部去构建它。我们在开发过程中使用这个特性

SpringRunner是SpringJUnit4ClassRunner的一个别名。
@RunWith(SpringRunner.class) 等价 @RunWith(SpringJUnit4ClassRunner.class) //SpringRunner 继承了SpringJUnit4ClassRunner，没有扩展任何功能；使用前者，名字简短而已

@RunWith（SpringRunner.class） //spring注解启用

@ContextConfiguration : 加载配置文件
单个文件 @ContextConfiguration(Locations="../applicationContext.xml")
@ContextConfiguration(classes = SimpleConfiguration.class)
多个文件时，可用
@ContextConfiguration(locations = { "classpath*:/spring1.xml", "classpath*:/spring2.xml" })


=============================================================================
@Configuration //告诉sprin该类是一个配置类 相当于我们所写的xxx.xml配置文件
@Bean //给容器中注入一个Bean，相当于<bean></bean>进行实例化一个bean
@ComponentScan() //  等同于：<context:component-scan  base-package=""></context:component-scan>
@Scope //bean作用域定义 默认单例  prototype  多实例的      singleton-》单例


-----------------------------------------------------------------------
spring-boot-starter-parent 与 spring-boot-dependencies
参考：https://www.cnblogs.com/sjshare/p/10669001.html
1.继承spring-boot-starter-parent
<parent>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-parent</artifactId>
   <version>2.1.3.RELEASE</version>
</parent>

使用这个配置，你还可以通过property覆盖内部的依赖。例如，在pom.xml中升级Spring Data release train。
<properties>
     <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
</properties>
可以通过spring-boot-dependencies pom，查看支持的属性列表。

2.spring-boot-dependencies 通过scope=import 来进行版本管理
<dependencyManagement> //父pom中的依赖版本管理
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.1.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

这种方式不能使用property的形式覆盖原始的依赖项。要达到同样的效果，需要在dependencyManagement里面的spring-boot-dependencies之前添加依赖的东西。
例如，要升级Spring Data release train，pom.xml应该是这样的：
<dependencyManagement>
    <dependencies>
        <!-- Override Spring Data release train provided by Spring Boot -->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-releasetrain</artifactId>
            <version>Fowler-SR2</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.1.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>


=====================================================================================
pluginManagement
dependencyManagement

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.0.1.RELEASE</version>
</parent>
或者在父工程中
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.1.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
引入springBoot的相关依赖，后面子工程中直接引用依赖时不用再指定版号即可

============================================================================
@SpringBootTest(classes = App.class)//指定sprintBoot启动类	获取启动类、加载配置，确定装载Spring Boot。
@TestPropertySource("classpath:pay.properties") //测试类中加载属性文件


@RunWith(SpringRunner.class) //启用spring测试
@ContextConfiguration(classes = ConfigTest.class)  //加载配置类 或者通过@Import(ConfigTest.class)也可以
@TestPropertySource("classpath:application.properties") //指定加载配置文件而非test目录resource下的资源
public class TestA {
    @Resource
    private ConfigTest test;

    @Test
    public void testA(){
        System.out.println(test.getEsurl());
    }
}



@RunWith(SpringRunner.class)
@Import({TestBean.class,JestClientUtils.class}) //导入测试类自动注入到容器
@TestPropertySource("classpath:application.properties") //加载指定配置属性文件
public class ElasticsearchJestTest {
    @Autowired
    private TestBean testBean;

    @Autowired
    private JestClientUtils jestClientUtils;


    @Test
    public void testA(){
     System.out.println("::::::="+jestClientUtils.getEsUrl());
      testBean.getName();

    }
}

=============================================================
@PropertySource("*.properties")  //加载指定属性文件
<1>配置@Value使用  //将指定属性文件中指定属性值绑定至当前JAVA对应属性上
<2>配合@ConfigurationProperties使用  //将指定的属性文件属性绑定至当前JAVA类

@Component
@PropertySource(value = {"demo/props/demo.properties"})
public class ReadByPropertySourceAndValue {

    @Value("${demo.name}")
    private String name;

    @Value("${demo.sex}")
    private int sex;

    @Value("${demo.type}")
    private String type;

    @Override
    public String toString() {
        return "ReadByPropertySourceAndValue{" +
                "name='" + name + '\'' +
                ", sex=" + sex +
                ", type='" + type + '\'' +
                '}';
    }
}
--------------------------------------------------------------
@Component
@PropertySource(value = {"demo/props/demo.properties"})
//@PropertySource("classpath:/com/acme/app.properties")
@ConfigurationProperties(prefix = "demo")
public class ReadByPropertySourceAndConfProperties {

    private String name;

    private int sex;

    private String type;

    public void setName(String name) {
        this.name = name;
    }

    public void setSex(int sex) {
        this.sex = sex;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public int getSex() {
        return sex;
    }

    public String getType() {
        return type;
    }

    @Override
    public String toString() {
        return "ReadByPropertySourceAndConfProperties{" +
                "name='" + name + '\'' +
                ", sex=" + sex +
                ", type='" + type + '\'' +
                '}';
    }
}

=====================================================================================================
1.实现 CommandLineRunner 接口，Springboot启动前 SpringApplication.run（）前执行动作。多个需要指定执行顺序加@Order(1)

2.@SpringBootConfiguration注解是@Configuration注解的派生注解，跟@Configuration注解的功能一致，标注这个类是一个配置类，只不过@SpringBootConfiguration是springboot的注解，
而@Configuration是spring的注解

3.@Configuration 表明所注解类为配置类
@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器

4.@ConfigurationProperties 绑定属性及配置文件
@ConfigurationProperties(prefix = "myapp.mail", ignoreInvalidFields = true) //

@EnableConfigurationProperties(HelloServiceProperties.class) //手动注入加载指定属性配置类
@EnableConfigurationProperties注解的作用是：使使用 @ConfigurationProperties 注解的类生效。

@ConfigurationProperties 与 @EnableConfigurationProperties 的关系。
@EnableConfigurationProperties 文档中解释：
当@EnableConfigurationProperties注解应用到你的@Configuration时， 任何被@ConfigurationProperties注解的beans将自动被Environment属性配置

与@Component配合使用 将配置类作组件注入





5.@ImportResource("classpath:applicationContext-configuration.xml"):将xml文件中配置的bean，也引用到配置类中，以便在该配置类中使用xml文件中配置好的bean



@Component
public class OutputPropsRunner implements CommandLineRunner {

    private static final Logger LOGGER = LoggerFactory.getLogger(OutputPropsRunner.class);

    @Autowired
    private ReadByPropertySourceAndValue readByPropertySourceAndValue;

    @Autowired
    private ReadByPropertySourceAndConfProperties readByPropertySourceAndConfProperties;


    @Override
    public void run(String... args) throws Exception {
        LOGGER.info(readByPropertySourceAndValue.toString());
        LOGGER.info(readByPropertySourceAndConfProperties.toString());
    }

}
===================================================
@EnableConfigurationProperties
@ConfigurationProperties
@Configuration

@ContextConfiguration(locations = { "classpath*:/spring1.xml", "classpath*:/spring2.xml" })
@ContextConfiguration(classes = SimpleConfiguration.class)


有点要注意的，就是一旦使用@Autowired那就默认代表当前Bean一定是已经存在的，如果为null，会报错。所以这里要修改下。
@Autowired(required=false) //required=false 的意思就是允许当前的Bean对象为null。

@ConditionalOnBean         //   当给定的在bean存在时,则实例化当前Bean
@ConditionalOnMissingBean  //   当给定的在bean不存在时,则实例化当前Bean
@ConditionalOnClass        //   当给定的类名在类路径上存在，则实例化当前Bean
@ConditionalOnMissingClass //   当给定的类名在类路径上不存在，则实例化当前Bean

------------------------------------------------------------------------------------------------------------
通过@Value("${xx.xx}")获取配置文件.properties中的配置信息

@Value将属性文件中指定的KEY-value值注入赋值给类非静态属性
如下：
1.直接在在类属性上方
@Value("${xx.xx}")
private String name;

2.或者属性SETTER方法上(静态变量通过此方法变通下，在方法内部将值赋值给静态方法)
@Value("${xx.xx}")
public void setName(String name){}

3.注意：@Value对应的类上需要加@Configuration 或 @Component

-----------------------------------------------------------------------------------------------------------------------
Spring应用启动过程中，肯定是要自动扫描有@Component注解的类，加载类并初始化对象进行自动注入。
加载类时首先要执行static静态代码块中的代码，之后再初始化对象时会执行构造方法。在对象注入完成后，
调用带有@PostConstruct注解的方法。当容器启动成功后，再根据@Order注解的顺序调用CommandLineRunner和ApplicationRunner接口类中的run方法。
因此，加载顺序为static>constructer>@PostConstruct>CommandLineRunner（接口）和ApplicationRunner.

Spring的核心，是IOC注入，但是静态方法，是在注入IOC之前执行，如果直接在静态方法中引用Spring IOC注入的变量，执行时会出现该变量为NULL

 https://blog.csdn.net/evo_steven/article/details/86005965
 @Scheduled
 
 
 -----------------------------------------------------------------
 1. spring-boot-starter-parent（控制版本信息）
 <parent>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-parent</artifactId>
   <version>2.1.4.RELEASE</version>
   <relativePath/> 
</parent>

2.spring-boot-starter //Spring Boot的核心启动器，包含了自动配置、日志和YAML

3. spring-boot-starter-web
web的场景，自动帮我们引入了web模块开发需要的相关jar包

4. spring-boot-starter-test
springboot程序测试依赖，如果是自动创建项目默认添加


pom.xml中
查找顺序：relativePath元素中的地址C本地仓库C远程仓库
<relativePath/>设定一个空值将始终从仓库中获取，不从本地路径获取